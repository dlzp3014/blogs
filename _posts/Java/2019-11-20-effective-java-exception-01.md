---
layout: post
title: "Java中只针对异常的情况下才使用异常"
date: 2019-11-20 08:38:00
categories: Java 
tags: Effective-Java Java-Coding
---

* content
{:toc}

异常机制的设计初衷是用于不正常的情形，`即异常应该只用于异常的情况下，永远不应该用于正常的控制流程`，如下代码，使用异常控制终止无限循环:

```java
//错误实例
try{
	while(true){
		range[i++].climb()
	}
}catch(ArrayIndexOutOfBoundsException e){
}
```




如上所示的代码片段基于异常的循环模式不见模糊了代码的意图，降低了性能，还不能保证正常的工作: 如果出现了不相关的Bug，这个模式会掩盖掉异常，极大地增加了调试过程的复杂性。一般地，应该优先使用标准的、容易理解的模式，而不是那些声称可以提供更好性能的、弄巧成拙的方法。即使真的能够改进性能，面对平台实现的不断改进，这种模式的性能也不可能一直保持


`设计良好的API不应该强迫它的客户端为了正常的控制流程而使用异常`: 如果类具有`状态相关`(state-dependent)的方法，即只有在特定的不可预知的条件下才可以被调用的方法，这个类往往也应该有一个单独的`状态测试`(state-testing)方法，即指示是否可以调用这个状态相关的方法。如Iterator接口就有一个`状态相关`的`next`方法，以及相应的状态测试方法`hasNext`，这使得利用传统的for循环(以及for-each:内部使用了hasNext方法)对集合进行迭代:

```java
for (Iterable<Foo> i = collection.iterator();i.hasNext() ; ) {
	Foo foo = i.next();
}
```

如果缺失Iterator的hasNext方法，客户端将被迫使用异常来控制流程:

```java
//除了代码繁琐且令人误解之外，这个基于异常的模式执行效率也很差，并且还有可能覆盖系统中其他不相关的Bug
try{
	Iterable<Foo> i = collection.iterator();
	while(true){
		Foo foo = i.next();
	}


}catch(NoSuchElementException e){

}

```

另一种提供单独的状态测试方法是: 如果`状态相关`的方法无法执行想要的计算，可以让它返回一个零长度的Optinal值或者返回一个可识别的值，如Null。

对于`状态测试方法`和`Optainal返回值或可识别的返回值`的使用有如下指导原则:

如果对象将在缺少外部同步的情况下被并发的访问或者可被外界改变状态，就必须使用Optional返回值或者可识别的返回值，因此在调用`状态测试`方法和调用对应的`状态相关`方法的时间间隔之中，对象的状态有可能发生变化。如果单独的`状态测试`方法必须必须重复`状态相关`方法的工作，从性能的角度考虑，就应该使用可被识别的返回值。如果其他方面都等同，`状态测试`方法则优于可被识别的返回值(可读性、对于使用不当的情形可更加易于检测和改正: 如果忘了调用状态检测方法，状态相关的方法就会抛出异常，使这个Bug变得明显;如果忘了检测可识别的返回，这个Bug就很难被发现[Optianl返回值不会有这方面的问题])

总结：`异常是为了在异常情况下使用而设计的，不要将它们用于普通的控制流程，也不要编写迫使它们这么做的API`
