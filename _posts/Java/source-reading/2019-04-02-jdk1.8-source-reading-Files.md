---
layout: post
title:  "JDK1.7源码-Files"
date:   2019-04-02 22:05:00
categories: java 
tags: JDK-Source-Reading JDK-Nio
---

* content
{:toc}

Files类主要用于Path对象相关文件、目录的操作，包括创建、删除、移动或者重命名、访问文件属性、遍历文件树、基于JDK1.8提供的Stream等操作


## 类描述

```java
/**
 * This class consists exclusively(专有地) of static methods that operate on files 操作文件，目录或者其他类型的文件,
 * directories, or other types of files.
 *
 * <p> In most cases大部分情况下, the methods defined here will delegate to the associated 当前方法定义将委托给关联的文件系统提供者执行文件操作
 * file system provider to perform the file operations.
 *
 * @since 1.7
 */

public final class Files {
    private Files() { }
    /**
     * Returns the {@code FileSystemProvider} to delegate to. 返回委托给文件系统提供者
     */
    private static FileSystemProvider provider(Path path) {
        return path.getFileSystem().provider();
    }

    /**
     * Convert a Closeable to a Runnable by converting checked IOException 将closeable转换为Runnable用于转换检查异常为运行时异常UncheckedIOException
     * to UncheckedIOException
     */
    private static Runnable asUncheckedRunnable(Closeable c) {
        return () -> {
            try {
                c.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        };
    }
}
```







## 静态方法

### 操作文件内容

- InputStream newInputStream(Path path, OpenOption... options):创建输入流

- OutputStream newOutputStream(Path path, OpenOption... options)：创建输出流

- SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options,FileAttribute<?>... attrs)：创建可查找字节管道
  
  SeekableByteChannel newByteChannel(Path path, OpenOption... options)

```java
/**
 * Opens a file , returning an input stream to read from the file. The stream 打开文件，返回输入流用于从文件中读取
 * will not be buffered, and is not required to support the {@link 流不缓存且不需要支持mark或者reset方法
 * InputStream#mark mark} or {@link InputStream#reset reset} methods. The 
 * stream will be safe for access by multiple concurrent threads. Reading 多个并发线程访问流是安全的
 * commences at the beginning of the file在文件开始阅读. Whether the returned stream is 返回的流是否为异步closeable或者
 * <i>asynchronously closeable</i> and/or <i>interruptible</i> is 可中断 highly
 * file system provider specific and therefore not specified. 系统文件提供商指定和不指定
 *
 * <p> The {@code options} parameter determines how the file is opened. options参数确定怎样打开文件
 * If no options are present then it is equivalent to opening the file with 没有时表明等于打开文件使用读操作
 * the {@link StandardOpenOption#READ READ} option. In addition to the {@code
 * READ} option, an implementation may also support additional implementation 附件READ操作，
 * specific options.
 *
 * @param   path
 *          the path to the file to open path用于打开文件
 * @param   options
 *          options specifying how the file is opened 指定操作怎样打开文件
 *
 * @return  a new input stream 返回新的输入流
 *
 * @throws  IllegalArgumentException
 *          if an invalid combination of options is specified
 * @throws  UnsupportedOperationException
 *          if an unsupported option is specified
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the file.
 */
public static InputStream newInputStream(Path path, OpenOption... options)
    throws IOException
{
    return provider(path).newInputStream(path, options);
}

/**
 * Opens or creates a file, returning an output stream that may be used to 打开或者创建一个文件，返回一个输出流，可用于将字节写入文件
 * write bytes to the file. The resulting stream will not be buffered. The
 * stream will be safe for access by multiple concurrent threads. Whether
 * the returned stream is <i>asynchronously closeable</i> and/or
 * <i>interruptible</i> is highly file system provider specific and
 * therefore not specified.
 *
 * <p> This method opens or creates a file in exactly the manner specified 正确方式打开或者创建文件通过newByteChannel方法
 * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}
 * method with the exception that the {@link StandardOpenOption#READ READ} 除了读操作可能不在选项数组中
 * option may not be present in the array of options. If no options are 没有没有操作参数，代码方法工作为CREATE和WRITE操作
 * present then this method works as if the {@link StandardOpenOption#CREATE
 * CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},
 * and {@link StandardOpenOption#WRITE WRITE} options are present. In other 换句话说，打开文件用于写、创建文件如果它不存在或者最初截断现有的大小为0，如果不存在时
 * words, it opens the file for writing, creating the file if it doesn't 
 * exist, or initially truncating an existing {@link #isRegularFile
 * regular-file} to a size of {@code 0} if it exists.
 *
 * <p> <b>Usage Examples:</b>
 * <pre>
 *     Path path = ...
 *
 *     // truncate and overwrite an existing file, or create the file if 截断并覆盖现有文件或者创建文件
 *     // it doesn't initially exist 如果最初不存在，
 *     OutputStream out = Files.newOutputStream(path);
 *
 *     // append to an existing file, fail if the file does not exist 缀加已存在文件，失败如果不存在
 *     out = Files.newOutputStream(path, APPEND);
 *
 *     // append to an existing file, create file if it doesn't initially exist 如果最初不存在创建，缀加已存在文件
 *     out = Files.newOutputStream(path, CREATE, APPEND);
 *
 *     // always create new file, failing if it already exists 总是创建文件，失败如果它已经存在
 *     out = Files.newOutputStream(path, CREATE_NEW);
 * </pre>
 *
 * @param   path
 *          the path to the file to open or create ： path 用于文件打开或者创建
 * @param   options
 *          options specifying how the file is opened ： 指定的options怎样打开文件 
 *
 * @return  a new output stream
 *
 * @throws  IllegalArgumentException
 *          if {@code options} contains an invalid combination of options
 * @throws  UnsupportedOperationException
 *          if an unsupported option is specified
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access to the file. The {@link
 *          SecurityManager#checkDelete(String) checkDelete} method is
 *          invoked to check delete access if the file is opened with the
 *          {@code DELETE_ON_CLOSE} option.
 */
public static OutputStream newOutputStream(Path path, OpenOption... options)
    throws IOException
{
    return provider(path).newOutputStream(path, options);
}

/**
 * Opens or creates a file, returning a seekable byte channel to access the 打开或创建文件，返回一个可查找的字节通道、访问文件
 * file.
 *
 * <p> The {@code options} parameter determines how the file is opened. 操作参数确认怎样打开文件，
 * The {@link StandardOpenOption#READ READ} and {@link 读和写操作确认文件打开应该用于读、写
 * StandardOpenOption#WRITE WRITE} options determine if the file should be
 * opened for reading and/or writing. If neither option (or the {@link 如果没有选项
 * StandardOpenOption#APPEND APPEND} option 缀加操作) is present then the file is 代表文件读取
 * opened for reading. By default reading or writing commence at the 通过默认读、写
 * beginning of the file.
 *
 * <p> In the addition to {@code READ} and {@code WRITE}, the following
 * options may be present:
 *
 * <table border=1 cellpadding=5 summary="Options">
 * <tr> <th>Option</th> <th>Description</th> </tr>
 * <tr>
 *   <td> {@link StandardOpenOption#APPEND APPEND} </td> 缀加
 *   <td> If this option is present then the file is opened for writing and 如果这个操作代表文件打开用于读和每次调用
 *     each invocation of the channel's {@code write} method first advances channel的write方法首先将文件文件移动到末尾
 *     the position to the end of the file and then writes the requested 写请求数据
 *     data. Whether the advancement of the position and the writing of the  是否前进位置和写入数据
 *     data are done in a single atomic operation(在单个原子操作中) is system-dependent 系统相关 and
 *     therefore unspecified. This option may not be used in conjunction 当前操作不能一起使用读或者TRUNCATE_EXISTING 操作
 *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. </td>
 * </tr>
 * <tr>
 *   <td> {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} </td> 存在截取
 *   <td> If this option is present then the existing file is truncated to 这个操作代表文件存在，被截断为0字节的大小
 *   a size of 0 bytes. This option is ignored when the file is opened only 当文件已经打开仅用于读，可忽略
 *   for reading. </td>
 * </tr>
 * <tr>
 *   <td> {@link StandardOpenOption#CREATE_NEW CREATE_NEW} </td>  新建创建
 *   <td> If this option is present then a new file is created, failing if 创建新文件，如已经存在失败或者是一个符号链接
 *   the file already exists or is a symbolic link. When creating a file the 当创建文件时检查文件存在和创建的文件，如果不存在
 *   check for the existence of the file and the creation of the file if it
 *   does not exist is atomic with respect to other file system operations. 相对于其他文件系统操作的原子性
 *   This option is ignored when the file is opened only for reading. </td> 如果打开的文件只用于读，可忽略
 * </tr>
 * <tr>
 *   <td > {@link StandardOpenOption#CREATE CREATE} </td> 创建
 *   <td> If this option is present then an existing file is opened if it 如果存在开发存在的文件否则创建新文件
 *   exists, otherwise a new file is created. This option is ignored if the
 *   {@code CREATE_NEW} option is also present or the file is opened only
 *   for reading. </td>
 * </tr>
 * <tr>
 *   <td > {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} </td> 删除、关闭
 *   <td> When this option is present then the implementation makes a 实现尽最大努力附加删除文件，当通过SeekableByteChannel.
 *   <em>best effort</em> attempt to delete the file when closed by the close方法关闭时
 *   {@link SeekableByteChannel#close close} method. If the {@code close} 如果close方法没有调用，
 *   method is not invoked then a <em>best effort</em> attempt is made to
 *   delete the file when the Java virtual machine terminates. </td> 删除文件档Java虚拟机终止时
 * </tr>尽最大努力
 * <tr>
 *   <td>{@link StandardOpenOption#SPARSE SPARSE} </td> 稀疏文件
 *   <td> When creating a new file this option is a <em>hint</em> 暗示 that the
 *   new file will be sparse. This option is ignored when not creating
 *   a new file. </td>
 * </tr>
 * <tr>
 *   <td> {@link StandardOpenOption#SYNC SYNC} </td> 同步
 *   <td> Requires that every update to the file's content or metadata be 每次更新文件内容或元数据同步写入底层存储设备
 *   written synchronously to the underlying storage device. (see <a
 *   href="package-summary.html#integrity"> Synchronized I/O file
 *   integrity</a>). </td>
 * </tr>
 * <tr>
 *   <td> {@link StandardOpenOption#DSYNC DSYNC} </td>
 *   <td> Requires that every update to the file's content be written
 *   synchronously to the underlying storage device. (see <a
 *   href="package-summary.html#integrity"> Synchronized I/O file
 *   integrity</a>). </td>
 * </tr>
 * </table>
 *
 * <p> An implementation may also support additional implementation specific
 * options.
 *
 * <p> The {@code attrs} parameter is optional {@link FileAttribute attrs参数是文件属性
 * file-attributes} to set atomically when a new file is created. 当创建文件时自动设置
 *
 * <p> In the case of the default provider, the returned seekable byte channel 默认提供的情况下，返回可查找字节通道
 * is a {@link java.nio.channels.FileChannel}.
 *
 * <p> <b>Usage Examples:</b>
 * <pre>
 *     Path path = ...
 *
 *     // open file for reading 打开流用于读
 *     ReadableByteChannel rbc = Files.newByteChannel(path, EnumSet.of(READ)));
 *
 *     // open file for writing to the end of an existing file, creating 打开文件用于写在存在文件的末尾，如果不存在创建文件
 *     // the file if it doesn't already exist
 *     WritableByteChannel wbc = Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));
 *
 *     // create file with initial permissions, opening it for both reading and writing 创建文件通过初始化权限，打开用于读写
 *     {@code FileAttribute<Set<PosixFilePermission>> perms = ...}
 *     SeekableByteChannel sbc = Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);
 * </pre>
 *
 * @param   path
 *          the path to the file to open or create
 * @param   options
 *          options specifying how the file is opened
 * @param   attrs
 *          an optional list of file attributes to set atomically when 当创建文件时自动设置文件属性
 *          creating the file
 *
 * @return  a new seekable byte channel 可查找字节管道
 *
 * @throws  IllegalArgumentException
 *          if the set contains an invalid combination of options
 * @throws  UnsupportedOperationException
 *          if an unsupported open option is specified or the array contains
 *          attributes that cannot be set atomically when creating the file
 * @throws  FileAlreadyExistsException
 *          if a file of that name already exists and the {@link
 *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified
 *          <i>(optional specific exception)</i>
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the path if the file is
 *          opened for reading. The {@link SecurityManager#checkWrite(String)
 *          checkWrite} method is invoked to check write access to the path
 *          if the file is opened for writing. The {@link
 *          SecurityManager#checkDelete(String) checkDelete} method is
 *          invoked to check delete access if the file is opened with the
 *          {@code DELETE_ON_CLOSE} option.
 *
 * @see java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])
 */
public static SeekableByteChannel newByteChannel(Path path,
                                                 Set<? extends OpenOption> options,
                                                 FileAttribute<?>... attrs)
    throws IOException
{
    return provider(path).newByteChannel(path, options, attrs);
}

/**
 * Opens or creates a file, returning a seekable byte channel to access the 打开或创建文件，返回可查找字节管道用于访问文件
 * file.
 *
 * <p> This method opens or creates a file in exactly the manner specified(完全按照指定的方式)
 * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}
 * method.
 *
 * @param   path
 *          the path to the file to open or create
 * @param   options
 *          options specifying how the file is opened
 *
 * @return  a new seekable byte channel
 *
 * @throws  IllegalArgumentException
 *          if the set contains an invalid combination of options
 * @throws  UnsupportedOperationException
 *          if an unsupported open option is specified
 * @throws  FileAlreadyExistsException
 *          if a file of that name already exists and the {@link
 *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified
 *          <i>(optional specific exception)</i>
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the path if the file is
 *          opened for reading. The {@link SecurityManager#checkWrite(String)
 *          checkWrite} method is invoked to check write access to the path
 *          if the file is opened for writing. The {@link
 *          SecurityManager#checkDelete(String) checkDelete} method is
 *          invoked to check delete access if the file is opened with the
 *          {@code DELETE_ON_CLOSE} option.
 *
 * @see java.nio.channels.FileChannel#open(Path,OpenOption[])
 */
public static SeekableByteChannel newByteChannel(Path path, OpenOption... options)
    throws IOException
{
    Set<OpenOption> set = new HashSet<OpenOption>(options.length);
    Collections.addAll(set, options);
    return newByteChannel(path, set);
}
```

### 操作目录

-  DirectoryStream<Path> newDirectoryStream(Path dir)：新建DirectoryStream(iterate over the entries in a directory),用于遍历文件目录

   DirectoryStream<Path> newDirectoryStream(Path dir, String glob)：
   		Glob是一种模式，它使用通配符来指定文件名，具体使用请参考： 【URL】: Java NIO中的Glob模式使用

   DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter)


```java
private static class AcceptAllFilter
        implements DirectoryStream.Filter<Path>
{
    private AcceptAllFilter() { }

    @Override
    public boolean accept(Path entry) { return true; }

    static final AcceptAllFilter FILTER = new AcceptAllFilter();
}

/**
 * Opens a directory, returning a {@link DirectoryStream} to iterate over 打开一个目录，返回一个DirectoryStream用于迭代目录中的所有实体
 * all entries in the directory. The elements returned by the directory 通过DirectoryStream#iterator返回的元素类型是Path
 * stream's {@link DirectoryStream#iterator iterator} are of type {@code
 * Path}, each one representing an entry in the directory. The {@code Path} 每一个代表目录中的一个实体，Path对象的获取作为，如果通过 Path#resolve(Path)解析目录文件实体名对目录
 * objects are obtained as if by {@link Path#resolve(Path) resolving} the
 * name of the directory entry against {@code dir}.
 *
 * <p> When not using the try-with-resources construct, then directory 当没有使用try-with-resources 尝试释放资源结构时，目录流close方法将被调用，在完成迭代以便释放所有资源
 * stream's {@code close} method should be invoked after iteration is
 * completed so as to free any resources held for the open directory. 持有打开的目录
 *
 * <p> When an implementation supports operations on entries in the 当实现支持的操作实体在目录文件中执行race-free方式时，返回目录流是SecureDirectoryStream
 * directory that execute in a race-free manner then the returned directory
 * stream is a {@link SecureDirectoryStream}.
 *
 * @param   dir
 *          the path to the directory 目录path
 *
 * @return  a new and open {@code DirectoryStream} object 返回新的打开DirectoryStream对象
 *
 * @throws  NotDirectoryException
 *          if the file could not otherwise be opened because it is not
 *          a directory <i>(optional specific exception)</i>
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the directory.
 */
public static DirectoryStream<Path> newDirectoryStream(Path dir)
    throws IOException
{
    return provider(dir).newDirectoryStream(dir, AcceptAllFilter.FILTER); DirectoryStream.Filter 过滤器
}

/**
 * Opens a directory, returning a {@link DirectoryStream} to iterate over
 * the entries in the directory. The elements returned by the directory
 * stream's {@link DirectoryStream#iterator iterator} are of type {@code
 * Path}, each one representing an entry in the directory. The {@code Path}
 * objects are obtained as if by {@link Path#resolve(Path) resolving} the
 * name of the directory entry against {@code dir}. The entries returned by 通过迭代器返回的实体是通过匹配文件名过滤的
 * the iterator are filtered by matching the {@code String} representation
 * of their file names against the given <em>globbing</em> pattern.
 *
 * <p> For example, suppose we want to iterate over the files ending with 文件名已java结尾
 * ".java" in a directory:
 * <pre>
 *     Path dir = ...
 *     try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, "*.java")) {
 *         :
 *     }
 * </pre>
 *
 * <p> The globbing pattern is specified by the {@link 通配符模式通过FileSystem#getPathMatcher指定
 * FileSystem#getPathMatcher getPathMatcher} method.
 *
 * <p> When not using the try-with-resources construct, then directory
 * stream's {@code close} method should be invoked after iteration is
 * completed so as to free any resources held for the open directory.
 *
 * <p> When an implementation supports operations on entries in the
 * directory that execute in a race-free manner then the returned directory
 * stream is a {@link SecureDirectoryStream}.
 *
 * @param   dir
 *          the path to the directory
 * @param   glob
 *          the glob pattern 通配符匹配操作符模式
 *
 * @return  a new and open {@code DirectoryStream} object
 *
 * @throws  java.util.regex.PatternSyntaxException
 *          if the pattern is invalid
 * @throws  NotDirectoryException
 *          if the file could not otherwise be opened because it is not
 *          a directory <i>(optional specific exception)</i>
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the directory.
 */
public static DirectoryStream<Path> newDirectoryStream(Path dir, String glob)
    throws IOException
{
    // avoid creating a matcher if all entries are required. 如果需要所有的实体，避免创建匹配器
    if (glob.equals("*"))
        return newDirectoryStream(dir); 

    // create a matcher and return a filter that uses it. 创建一个匹配器，返回一个过滤器使用
    FileSystem fs = dir.getFileSystem(); //通过Path对象获取文件系统
    final PathMatcher matcher = fs.getPathMatcher("glob:" + glob); //获取Glob模式的PathMatcher
    DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<Path>() { //创建目录文件过滤器
        @Override
        public boolean accept(Path entry)  {
            return matcher.matches(entry.getFileName()); //匹配文件名
        }
    };
    return fs.provider().newDirectoryStream(dir, filter);
}

/**
 * Opens a directory, returning a {@link DirectoryStream} to iterate over
 * the entries in the directory. The elements returned by the directory
 * stream's {@link DirectoryStream#iterator iterator} are of type {@code
 * Path}, each one representing an entry in the directory. The {@code Path}
 * objects are obtained as if by {@link Path#resolve(Path) resolving} the
 * name of the directory entry against {@code dir}. The entries returned by
 * the iterator are filtered by the given {@link DirectoryStream.Filter 通过给定的 DirectoryStream.Filter 过滤实体
 * filter}.
 *
 * <p> When not using the try-with-resources construct, then directory
 * stream's {@code close} method should be invoked after iteration is
 * completed so as to free any resources held for the open directory.
 *
 * <p> Where the filter terminates due to an uncaught error or runtime 当过滤终止，由于未捕获的错误或者运行时异常时，传播给
 * exception then it is propagated to the {@link Iterator#hasNext() Iterator#hasNext()或者Iterator#next() 方法
 * hasNext} or {@link Iterator#next() next} method. Where an {@code 
 * IOException} is thrown, it results in the {@code hasNext} or {@code 抛出IOException异常的地方，结果在hasNext或者next方法
 * next} method throwing a {@link DirectoryIteratorException} with the 由于IOException引起抛出一个DirectoryIteratorException
 * {@code IOException} as the cause.
 *
 * <p> When an implementation supports operations on entries in the
 * directory that execute in a race-free manner then the returned directory
 * stream is a {@link SecureDirectoryStream}.
 *
 * <p> <b>Usage Example:</b>
 * Suppose we want to iterate over the files in a directory that are 如获取大于8ke的文件大小
 * larger than 8K.
 * <pre>
 *     DirectoryStream.Filter&lt;Path&gt; filter = new DirectoryStream.Filter&lt;Path&gt;() {
 *         public boolean accept(Path file) throws IOException {
 *             return (Files.size(file) &gt; 8192L);
 *         }
 *     };
 *     Path dir = ...
 *     try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, filter)) {
 *         :
 *     }
 * </pre>
 *
 * @param   dir
 *          the path to the directory
 * @param   filter
 *          the directory stream filter 目录流过滤器
 *
 * @return  a new and open {@code DirectoryStream} object
 *
 * @throws  NotDirectoryException
 *          if the file could not otherwise be opened because it is not 如果不是目录是抛出NotDirectoryException
 *          a directory <i>(optional specific exception)</i>
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the directory.
 */
public static DirectoryStream<Path> newDirectoryStream(Path dir,
                                                       DirectoryStream.Filter<? super Path> filter)
    throws IOException
{
    return provider(dir).newDirectoryStream(dir, filter);
}

```

### 创建和删除文件或者目录

- Path createFile(Path path, FileAttribute<?>... attrs) 创建文件

- Path createDirectory(Path dir, FileAttribute<?>... attrs) 创建目录

- Path createDirectories(Path dir, FileAttribute<?>... attrs) 创建目录集

- createAndCheckIsDirectory(Path dir, FileAttribute<?>... attrs) 创建目录，目录存在时，不进行任何操作

- Path createTempFile(Path dir,String prefix,String suffix,FileAttribute<?>... attrs)：创建临时文件，在close方法调用时删除

	Path createTempFile(String prefix,String suffix,FileAttribute<?>... attrs)

- createTempDirectory(Path dir,String prefix,FileAttribute<?>... attrs)：创建临时目录

	Path createTempDirectory(String prefix,FileAttribute<?>... attrs)

- Path createSymbolicLink(Path link, Path target,FileAttribute<?>... attrs)：创建符号连接

- createLink(Path link, Path existing)：创建连接(hard link)

- void delete(Path path):删除,如果是目录时，目录下不能有任何文件

- deleteIfExists(Path path)：如果存在时删除，如果是目录时，目录下不能有任何文件，可以使用walkFileTree删除目录和目录下文所有内容


```java
/**
 * Creates a new and empty file, failing if the file already exists. The 创建一个新的空文件，如果已经存在，失败
 * check for the existence of the file and the creation of the new file if 检查文件和创建新文件，如果不存在一个单个操作
 * it does not exist are a single operation that is atomic with respect to 相对其他所有文件系统活动可能会影响目录
 * all other filesystem activities that might affect the directory.
 *
 * <p> The {@code attrs} parameter is optional {@link FileAttribute attrs参数自动设置当创建文件时。
 * file-attributes} to set atomically when creating the file. Each attribute 每一属性通过FileAttribute#name 进行鉴定
 * is identified by its {@link FileAttribute#name name}. If more than one
 * attribute of the same name is included in the array then all but the last 如果不只有一个相同name 在数组中，最后出现将忽略
 * occurrence is ignored.
 *
 * @param   path
 *          the path to the file to create
 * @param   attrs
 *          an optional list of file attributes to set atomically when
 *          creating the file
 *
 * @return  the file
 *
 * @throws  UnsupportedOperationException
 *          if the array contains an attribute that cannot be set atomically 在创建文件时，数组包含的属性不能自动设置时
 *          when creating the file
 * @throws  FileAlreadyExistsException
 *          if a file of that name already exists 文件已经存在
 *          <i>(optional specific exception)</i>
 * @throws  IOException
 *          if an I/O error occurs or the parent directory does not exist
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access to the new file.
 */
public static Path createFile(Path path, FileAttribute<?>... attrs)
    throws IOException
{
    EnumSet<StandardOpenOption> options =
        EnumSet.<StandardOpenOption>of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE); //读写操作
    newByteChannel(path, options, attrs).close();
    return path;
}

/**
 * Creates a new directory. The check for the existence of the file and the 创建一个目录，检查文件存在和创建一个目录
 * creation of the directory if it does not exist are a single operation 如果不存在单一操作，
 * that is atomic with respect(遵循原子) to all other filesystem activities that might
 * affect the directory. The {@link #createDirectories createDirectories} createDirectories createDirectories方法应该被使用在需要创建所以不存在的父目录
 * method should be used where it is required to create all nonexistent
 * parent directories first.
 *
 * <p> The {@code attrs} parameter is optional {@link FileAttribute 
 * file-attributes} to set atomically when creating the directory. Each 创建目录是自动设置目录属性
 * attribute is identified by its {@link FileAttribute#name name}. If more
 * than one attribute of the same name is included in the array then all but
 * the last occurrence is ignored.
 *
 * @param   dir
 *          the directory to create
 * @param   attrs
 *          an optional list of file attributes to set atomically when
 *          creating the directory
 *
 * @return  the directory
 *
 * @throws  UnsupportedOperationException
 *          if the array contains an attribute that cannot be set atomically
 *          when creating the directory
 * @throws  FileAlreadyExistsException
 *          if a directory could not otherwise be created because a file of
 *          that name already exists <i>(optional specific exception)</i>
 * @throws  IOException
 *          if an I/O error occurs or the parent directory does not exist
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access to the new directory.
 */
public static Path createDirectory(Path dir, FileAttribute<?>... attrs)
    throws IOException
{
    provider(dir).createDirectory(dir, attrs);
    return dir;
}

/**
 * Creates a directory by creating all nonexistent parent directories first. 创建一个目录，首先创建不存在的父目录
 * Unlike the {@link #createDirectory createDirectory} method, an exception 不像createDirectory方法，如果不来不能创建不抛出异常，因为已经存在
 * is not thrown if the directory could not be created because it already
 * exists.
 *
 * <p> The {@code attrs} parameter is optional {@link FileAttribute
 * file-attributes} to set atomically when creating the nonexistent
 * directories. Each file attribute is identified by its {@link
 * FileAttribute#name name}. If more than one attribute of the same name is
 * included in the array then all but the last occurrence is ignored.
 *
 * <p> If this method fails, then it may do so after(之后创建其他) creating some, but not
 * all, of the parent directories.
 *
 * @param   dir
 *          the directory to create
 *
 * @param   attrs
 *          an optional list of file attributes to set atomically when
 *          creating the directory
 *
 * @return  the directory
 *
 * @throws  UnsupportedOperationException
 *          if the array contains an attribute that cannot be set atomically
 *          when creating the directory
 * @throws  FileAlreadyExistsException
 *          if {@code dir} exists but is not a directory <i>(optional specific 目录存在但是不是一个目录
 *          exception)</i>
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          in the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked prior to attempting to create a directory and
 *          its {@link SecurityManager#checkRead(String) checkRead} is
 *          invoked for each parent directory that is checked. If {@code
 *          dir} is not an absolute path then its {@link Path#toAbsolutePath
 *          toAbsolutePath} may need to be invoked to get its absolute path.
 *          This may invoke the security manager's {@link
 *          SecurityManager#checkPropertyAccess(String) checkPropertyAccess}
 *          method to check access to the system property {@code user.dir}
 */
public static Path createDirectories(Path dir, FileAttribute<?>... attrs)
    throws IOException
{
    // attempt to create the directory 尝试创建目录
    try {
        createAndCheckIsDirectory(dir, attrs);
        return dir;
    } catch (FileAlreadyExistsException x) {
        // file exists and is not a directory
        throw x;
    } catch (IOException x) {
        // parent may not exist or other reason
    }
    SecurityException se = null;
    try {
        dir = dir.toAbsolutePath();
    } catch (SecurityException x) {
        // don't have permission to get absolute path
        se = x;
    }
    // find a decendent that exists查找存在的子孙
    Path parent = dir.getParent();
    while (parent != null) {
        try {
            provider(parent).checkAccess(parent); //是否可访问
            break;
        } catch (NoSuchFileException x) {
            // does not exist
        }
        parent = parent.getParent(); //获取父Path
    }
    if (parent == null) {
        // unable to find existing parent
        if (se == null) {
            throw new FileSystemException(dir.toString(), null,
                "Unable to determine if root directory exists");
        } else {
            throw se;
        }
    }

    // create directories 创建目录
    Path child = parent;
    for (Path name: parent.relativize(dir)) { //相对Path，解析创建
        child = child.resolve(name); 
        createAndCheckIsDirectory(child, attrs);
    }
    return dir;
}

/**
 * Used by createDirectories to attempt to create a directory. A no-op 使用在尝试创建目录，
 * if the directory already exists. 如果目录存在是一个空操作
 */
private static void createAndCheckIsDirectory(Path dir,
                                              FileAttribute<?>... attrs)
    throws IOException
{
    try {
        createDirectory(dir, attrs); //创建目录
    } catch (FileAlreadyExistsException x) {
        if (!isDirectory(dir, LinkOption.NOFOLLOW_LINKS)) //是否为目录
            throw x;
    }
}

/**
 * Creates a new empty file in the specified directory, using the given 创建一个空文件在指定目录下，使用给定的前缀和后缀
 * prefix and suffix strings to generate its name. The resulting 生成名字
 * {@code Path} is associated with the same {@code FileSystem} as the given 
 * directory.
 *
 * <p> The details as to how the name of the file is constructed is 详细的怎样构造文件的名称实现
 * implementation dependent and therefore not specified. Where possible 依赖前缀和后缀
 * the {@code prefix} and {@code suffix} are used to construct candidate
 * names in the same manner as the {@link
 * java.io.File#createTempFile(String,String,File)} method.
 *
 * <p> As with the {@code File.createTempFile} methods, this method is only  正如 File.createTempFile方法，这个方法只是临时文件设施的一部分
 * part of a temporary-file facility. Where used as a <em>work files</em>, 使用在一个工作文件，
 * the resulting file may be opened using the {@link 结果文件可能在打开时使用DELETE_ON_CLOSE选项，
 * StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the
 * file is deleted when the appropriate {@code close} method is invoked. 当适当的调用close方法时，文件将被删除
 * Alternatively 做为选择, a {@link Runtime#addShutdownHook shutdown-hook}, or the
 * {@link java.io.File#deleteOnExit} mechanism may be used to delete the
 * file automatically. 自动删除文件
 *
 * <p> The {@code attrs} parameter is optional {@link FileAttribute
 * file-attributes} to set atomically when creating the file. Each attribute
 * is identified by its {@link FileAttribute#name name}. If more than one
 * attribute of the same name is included in the array then all but the last
 * occurrence is ignored. When no file attributes are specified, then the
 * resulting file may have more restrictive access permissions (限制访问权限)to files
 * created by the {@link java.io.File#createTempFile(String,String,File)}
 * method.
 *
 * @param   dir
 *          the path to directory in which to create the file 要在其中创建文件的目录的路径
 * @param   prefix
 *          the prefix string to be used in generating the file's name;  用于生成文件名称的前缀字符串
 *          may be {@code null}
 * @param   suffix
 *          the suffix string to be used in generating the file's name; 用于生成文件名称的后缀字符串
 *          may be {@code null}, in which case "{@code .tmp}" is used 为null时使用.tmp
 * @param   attrs
 *          an optional list of file attributes to set atomically when 可选的文件属性列表，创建文件时自动设置
 *          creating the file
 *
 * @return  the path to the newly created file that did not exist before 在这个方法调用前，不存在的新创建文件的路径
 *          this method was invoked
 *
 * @throws  IllegalArgumentException
 *          if the prefix or suffix parameters cannot be used to generate
 *          a candidate file name
 * @throws  UnsupportedOperationException
 *          if the array contains an attribute that cannot be set atomically
 *          when creating the directory
 * @throws  IOException
 *          if an I/O error occurs or {@code dir} does not exist
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access to the file.
 */
public static Path createTempFile(Path dir,
                                  String prefix,
                                  String suffix,
                                  FileAttribute<?>... attrs)
    throws IOException
{
    return TempFileHelper.createTempFile(Objects.requireNonNull(dir),
                                         prefix, suffix, attrs);
}

/**
 * Creates an empty file in the default temporary-file directory, using
 * the given prefix and suffix to generate its name. The resulting {@code
 * Path} is associated with the default {@code FileSystem}.
 *
 * <p> This method works in exactly the manner specified by the
 * {@link #createTempFile(Path,String,String,FileAttribute[])} method for
 * the case that the {@code dir} parameter is the temporary-file directory.
 *
 * @param   prefix
 *          the prefix string to be used in generating the file's name;
 *          may be {@code null}
 * @param   suffix
 *          the suffix string to be used in generating the file's name;
 *          may be {@code null}, in which case "{@code .tmp}" is used
 * @param   attrs
 *          an optional list of file attributes to set atomically when
 *          creating the file
 *
 * @return  the path to the newly created file that did not exist before
 *          this method was invoked
 *
 * @throws  IllegalArgumentException
 *          if the prefix or suffix parameters cannot be used to generate
 *          a candidate file name
 * @throws  UnsupportedOperationException
 *          if the array contains an attribute that cannot be set atomically
 *          when creating the directory
 * @throws  IOException
 *          if an I/O error occurs or the temporary-file directory does not
 *          exist
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access to the file.
 */
public static Path createTempFile(String prefix,
                                  String suffix,
                                  FileAttribute<?>... attrs)
    throws IOException
{
    return TempFileHelper.createTempFile(null, prefix, suffix, attrs);
}

/**
 * Creates a new directory in the specified directory, using the given 在指定的目录中创建新目录
 * prefix to generate its name.  The resulting {@code Path} is associated
 * with the same {@code FileSystem} as the given directory.
 *
 * <p> The details as to how the name of the directory is constructed is
 * implementation dependent and therefore not specified. Where possible
 * the {@code prefix} is used to construct candidate names.
 *
 * <p> As with the {@code createTempFile} methods, this method is only
 * part of a temporary-file facility. A {@link Runtime#addShutdownHook
 * shutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be
 * used to delete the directory automatically.
 *
 * <p> The {@code attrs} parameter is optional {@link FileAttribute
 * file-attributes} to set atomically when creating the directory. Each
 * attribute is identified by its {@link FileAttribute#name name}. If more
 * than one attribute of the same name is included in the array then all but
 * the last occurrence is ignored.
 *
 * @param   dir
 *          the path to directory in which to create the directory
 * @param   prefix
 *          the prefix string to be used in generating the directory's name;
 *          may be {@code null}
 * @param   attrs
 *          an optional list of file attributes to set atomically when
 *          creating the directory
 *
 * @return  the path to the newly created directory that did not exist before
 *          this method was invoked
 *
 * @throws  IllegalArgumentException
 *          if the prefix cannot be used to generate a candidate directory name
 * @throws  UnsupportedOperationException
 *          if the array contains an attribute that cannot be set atomically
 *          when creating the directory
 * @throws  IOException
 *          if an I/O error occurs or {@code dir} does not exist
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access when creating the
 *          directory.
 */
public static Path createTempDirectory(Path dir,
                                       String prefix,
                                       FileAttribute<?>... attrs)
    throws IOException
{
    return TempFileHelper.createTempDirectory(Objects.requireNonNull(dir),
                                              prefix, attrs);
}

/**
 * Creates a new directory in the default temporary-file directory, using 在默认临时文件目录中创建一个新目录
 * the given prefix to generate its name. The resulting {@code Path} is
 * associated with the default {@code FileSystem}.
 *
 * <p> This method works in exactly the manner specified by {@link
 * #createTempDirectory(Path,String,FileAttribute[])} method for the case
 * that the {@code dir} parameter is the temporary-file directory.
 *
 * @param   prefix
 *          the prefix string to be used in generating the directory's name;
 *          may be {@code null}
 * @param   attrs
 *          an optional list of file attributes to set atomically when
 *          creating the directory
 *
 * @return  the path to the newly created directory that did not exist before
 *          this method was invoked
 *
 * @throws  IllegalArgumentException
 *          if the prefix cannot be used to generate a candidate directory name
 * @throws  UnsupportedOperationException
 *          if the array contains an attribute that cannot be set atomically
 *          when creating the directory
 * @throws  IOException
 *          if an I/O error occurs or the temporary-file directory does not
 *          exist
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access when creating the
 *          directory.
 */
public static Path createTempDirectory(String prefix,
                                       FileAttribute<?>... attrs)
    throws IOException
{
    return TempFileHelper.createTempDirectory(null, prefix, attrs);
}

/**
 * Creates a symbolic link to a target <i>(optional operation)</i>. 创建指向目标的符号链接
 *
 * <p> The {@code target} parameter is the target of the link. It may be an target参数为连接的目标
 * {@link Path#isAbsolute absolute} or relative path and may not exist. When 它可能是目标的绝对或者相对路径并且可能不存在
 * the target is a relative path then file system operations on the resulting 当目标是相对路径是，在结果连接上的文件系统操作
 * link are relative to the path of the link.是相对路径的连接
 *
 * <p> The {@code attrs} parameter is optional {@link FileAttribute
 * attributes} to set atomically when creating the link. Each attribute is
 * identified by its {@link FileAttribute#name name}. If more than one attribute
 * of the same name is included in the array then all but the last occurrence
 * is ignored.
 *
 * <p> Where symbolic links are supported(支持符号链接), but the underlying {@link FileStore} FileStore不支持符号连接
 * does not support symbolic links, then this may fail with an {@link
 * IOException}. Additionally, some operating systems may require that the
 * Java virtual machine be started with implementation specific privileges特权 to
 * create symbolic links, in which case this method may throw {@code IOException}.
 *
 * @param   link
 *          the path of the symbolic link to create
 * @param   target
 *          the target of the symbolic link
 * @param   attrs
 *          the array of attributes to set atomically when creating the
 *          symbolic link
 *
 * @return  the path to the symbolic link
 *
 * @throws  UnsupportedOperationException
 *          if the implementation does not support symbolic links or the
 *          array contains an attribute that cannot be set atomically when
 *          creating the symbolic link
 * @throws  FileAlreadyExistsException
 *          if a file with the name already exists <i>(optional specific
 *          exception)</i>
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager
 *          is installed, it denies {@link LinkPermission}<tt>("symbolic")</tt>
 *          or its {@link SecurityManager#checkWrite(String) checkWrite}
 *          method denies write access to the path of the symbolic link.
 */
public static Path createSymbolicLink(Path link, Path target,
                                      FileAttribute<?>... attrs)
    throws IOException
{
    provider(link).createSymbolicLink(link, target, attrs);
    return link;
}

/**
 * Creates a new link (directory entry) for an existing file <i>(optional 创建一个存在的目录实体连接
 * operation)</i>.
 *
 * <p> The {@code link} parameter locates the directory entry to create. link参数定位要创建的目录项
 * The {@code existing} parameter is the path to an existing file. This existing参数是已经存在的文件路径
 * method creates a new directory entry(文件目录) for the file so that it can be
 * accessed using {@code link} as the path. On some file systems this is
 * known as creating a "hard link" 硬链接. Whether the file attributes are
 * maintained 维护 for the file or for each directory entry is file system
 * specific and therefore not specified. Typically, a file system requires
 * that all links (directory entries) for a file be on the same file system.
 * Furthermore, on some platforms, the Java virtual machine may require to
 * be started with implementation specific privileges to create hard links
 * or to create links to directories.
 *
 * @param   link
 *          the link (directory entry) to create
 * @param   existing
 *          a path to an existing file
 *
 * @return  the path to the link (directory entry)
 *
 * @throws  UnsupportedOperationException
 *          if the implementation does not support adding an existing file
 *          to a directory
 * @throws  FileAlreadyExistsException
 *          if the entry could not otherwise be created because a file of
 *          that name already exists <i>(optional specific exception)</i>
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager
 *          is installed, it denies {@link LinkPermission}<tt>("hard")</tt>
 *          or its {@link SecurityManager#checkWrite(String) checkWrite}
 *          method denies write access to either the link or the
 *          existing file.
 */
public static Path createLink(Path link, Path existing) throws IOException {
    provider(link).createLink(link, existing);
    return link;
}

/**
 * Deletes a file. 删除一个文件
 *
 * <p> An implementation may require to examine(检查) the file to determine if the 实现可能需要检查文件来确定是否是一个目录
 * file is a directory. Consequently(因此) this method may not be atomic (原子)with respect
 * to other file system operations(遵循其他文件系统).  If the file is a symbolic link then the 如果文件是一个符合连接时，符号连接它自己被删除，而不是最终的目标
 * symbolic link itself, not the final target of the link, is deleted.
 *
 * <p> If the file is a directory then the directory must be empty. In some 如果文件是一个目录时，目录必须为空
 * implementations a directory has entries for special files or links that
 * are created when the directory is created. In such implementations a
 * directory is considered empty when only the special entries exist.
 * This method can be used with the {@link #walkFileTree walkFileTree} walkFileTree方法可以删目录和全部实体
 * method to delete a directory and all entries in the directory, or an
 * entire <i>file-tree</i> where required.
 *
 * <p> On some operating systems 在一些操作系统上 it may not be possible to remove a file 可能无法删除文件 when
 * it is open and in use by this Java virtual machine or other programs. 打开在jvm中使用或者其他程序
 *
 * @param   path
 *          the path to the file to delete
 *
 * @throws  NoSuchFileException
 *          if the file does not exist <i>(optional specific exception)</i>
 * @throws  DirectoryNotEmptyException
 *          if the file is a directory and could not otherwise be deleted
 *          because the directory is not empty <i>(optional specific
 *          exception)</i>
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkDelete(String)} method
 *          is invoked to check delete access to the file
 */
public static void delete(Path path) throws IOException {
    provider(path).delete(path);
}

/**
 * Deletes a file if it exists. 如果文件存在删除
 *
 * <p> As with the {@link #delete(Path) delete(Path)} method, an
 * implementation may need to examine the file to determine if the file is a
 * directory. Consequently this method may not be atomic with respect to
 * other file system operations.  If the file is a symbolic link, then the
 * symbolic link itself, not the final target of the link, is deleted.
 *
 * <p> If the file is a directory then the directory must be empty. In some
 * implementations a directory has entries for special files or links that
 * are created when the directory is created. In such implementations a
 * directory is considered empty when only the special entries exist.
 *
 * <p> On some operating systems it may not be possible to remove a file when
 * it is open and in use by this Java virtual machine or other programs.
 *
 * @param   path
 *          the path to the file to delete
 *
 * @return  {@code true} if the file was deleted by this method; {@code
 *          false} if the file could not be deleted because it did not
 *          exist
 *
 * @throws  DirectoryNotEmptyException
 *          if the file is a directory and could not otherwise be deleted
 *          because the directory is not empty <i>(optional specific
 *          exception)</i>
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkDelete(String)} method
 *          is invoked to check delete access to the file.
 */
public static boolean deleteIfExists(Path path) throws IOException {
    return provider(path).deleteIfExists(path);
}


```


### 复制、移动文件

- Path copy(Path source, Path target, CopyOption... options)：复制文件到指定的目标中，如果source是一个目录，将创建一个空的目录，目录下的文件不进行复制，可以使用walkFileTree来复制目录及目录下的文件

- Path move(Path source, Path target, CopyOption... options)：将文件移动或重命名为目标文件，递归操作时，可以使用walkFileTree

```java
/**
 * Copy a file to a target file.   将文件复制到目标文件
 *
 * <p> This method copies a file to the target file with the {@code 此方法将文件复制到目标文件，通过options参数指定如果执行复制
 * options} parameter specifying how the copy is performed. By default, the 如果目标文件已经存在或者是一个符号连接时复制失败
 * copy fails if the target file already exists or is a symbolic link,
 * except if the source and target are the {@link #isSameFile same} file, in 除了如果source和target是相同文件，在这种情况下
 * which case the method completes without copying the file. File attributes 这个方法不复制文件的情况下完成
 * are not required to be copied to the target file. If symbolic links are 文件属性不需要复制到目标文件 如果支持符号链接，并且文件是一个符号链接时，链接的最终目标将被赋值
 * supported, and the file is a symbolic link, then the final target of the
 * link is copied. If the file is a directory then it creates an empty 如果文件是一个目录时，它将创建一个空目录，在目标位置
 * directory in the target location (entries in the directory are not 目录中的实体不复制
 * copied). This method can be used with the {@link #walkFileTree 使用walkFileTree可以复制目录及目录中的所有Neri
 * walkFileTree} method to copy a directory and all entries in the directory,
 * or an entire <i>file-tree</i> where required.
 *
 * <p> The {@code options} parameter may include any of the following: options参数可能包括下面任何值
 *
 * <table border=1 cellpadding=5 summary="">
 * <tr> <th>Option</th> <th>Description</th> </tr>
 * <tr>
 *   <td> {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} </td>REPLACE_EXISTING：如果目标文件存在时，如果它不是一个非空目录，目标文件将被替换
 *   <td> If the target file exists, then the target file is replaced if it
 *     is not a non-empty directory. If the target file exists and is a 如果目标文件存在且为一个符号链接
 *     symbolic link, then the symbolic link itself, not the target of 符号链接它自身替换，而不是目标链接
 *     the link, is replaced. </td>
 * </tr>
 * <tr>
 *   <td> {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} </td>  COPY_ATTRIBUTES：尝试复制文件属性关联到逐个目标文件
 *   <td> Attempts to copy the file attributes associated with this file to
 *     the target file. The exact file attributes (确切的文件属性)that are copied is platform
 *     and file system dependent and therefore unspecified. Minimally 最低限度地, the
 *     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is 如果支持source和target文件存储，lastModifiedTime复制到目标文件
 *     copied to the target file if supported by both the source and target
 *     file stores. Copying of file timestamps may result in precision 复制文件时间戳可能会导致精度下降
 *     loss. </td>
 * </tr>
 * <tr>
 *   <td> {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} </td> NOFOLLOW_LINKS:符号链接不允许，
 *   <td> Symbolic links are not followed. If the file is a symbolic link, 如果文件是一个符号链接是，符号链接本身复制，而不是复制链接的目标
 *     then the symbolic link itself, not the target of the link, is copied.
 *     It is implementation specific if file attributes can be copied to the 它是特定实现的，如果文件属性可以复制到新的连接
 *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be 换句话，COPY_ATTRIBUTES选择可能忽略符号连接的赋值
 *     ignored when copying a symbolic link. </td>
 * </tr>
 * </table>
 *
 * <p> An implementation of this interface may support additional
 * implementation specific options.
 *
 * <p> Copying a file is not an atomic operation. If an {@link IOException} 复制时不是一个原子操作
 * is thrown, then it is possible that the target file is incomplete or some 当目标文件是残缺的或者它的文件属性没有被复制从源文件时，将抛出异常
 * of its file attributes have not been copied from the source file. When
 * the {@code REPLACE_EXISTING} option is specified and the target file 当REPLACE_EXISTING选项被指定，且目标文件存在时，目标文件将被替换
 * exists, then the target file is replaced. The check for the existence of 检查文件存在和创建新的文件可能不是一个原子性
 * the file and the creation of the new file may not be atomic with respect
 * to other file system activities. 其他文件系统活动
 *
 * <p> <b>Usage Example:</b>
 * Suppose we want to copy a file into a directory, giving it the same file 假设我们要将一个文件复制到一个目录中
 * name as the source file: 赋予它与源文件相同的文件名
 * <pre>
 *     Path source = ...
 *     Path newdir = ...
 *     Files.copy(source, newdir.resolve(source.getFileName());  Path resolve(Path other)：根据此路径解析给定的路径，
 * </pre>
 *
 * @param   source
 *          the path to the file to copy 要复制的文件的路径
 * @param   target
 *          the path to the target file (may be associated with a different
 *          provider to the source path) 目标文件的路径(可能与其他文件相关联)源路径的提供者)
 * @param   options
 *          options specifying how the copy should be done 指定应如何复制的选项
 *
 * @return  the path to the target file 指向目标文件的路径
 *
 * @throws  UnsupportedOperationException
 *          if the array contains a copy option that is not supported
 * @throws  FileAlreadyExistsException
 *          if the target file exists but cannot be replaced because the
 *          {@code REPLACE_EXISTING} option is not specified <i>(optional
 *          specific exception)</i>
 * @throws  DirectoryNotEmptyException
 *          the {@code REPLACE_EXISTING} option is specified but the file
 *          cannot be replaced because it is a non-empty directory
 *          <i>(optional specific exception)</i>
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the source file, the
 *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked
 *          to check write access to the target file. If a symbolic link is
 *          copied the security manager is invoked to check {@link
 *          LinkPermission}{@code ("symbolic")}.
 */
public static Path copy(Path source, Path target, CopyOption... options)
    throws IOException
{
    FileSystemProvider provider = provider(source);
    if (provider(target) == provider) {
        // same provider 文件相同
        provider.copy(source, target, options);
    } else {
        // different providers
        CopyMoveHelper.copyToForeignTarget(source, target, options);
    }
    return target;
}

/**
 * Move or rename a file to a target file. 将文件移动或重命名为目标文件
 *
 * <p> By default, this method attempts to move the file to the target 默认实现，这个方法尝试移动文件到目标文件，如果目标文件存在失败，处理源文件与目标文件相同
 * file, failing if the target file exists except if the source and
 * target are the {@link #isSameFile same} file, in which case this method 这种情况下，方法无效
 * has no effect. If the file is a symbolic link then the symbolic link 如果文件是一个符号链接时，移动符号链接，链接的目标不移动
 * itself, not the target of the link, is moved. This method may be 这个方法可能移动一个空目录，
 * invoked to move an empty directory. In some implementations a directory 在一些实现中，一个目录包含指定的文件或者创建的连接
 * has entries for special files or links that are created when the 当目标被创建时
 * directory is created. In such implementations a directory is considered 在这样的实现中有一个目录被认为是空，当只有指定的实体存在
 * empty when only the special entries exist. When invoked to move a 当调用移动一个不为空的目录时，如果它不需要移动实体
 * directory that is not empty then the directory is moved if it does not
 * require moving the entries in the directory.  For example, renaming a 如重命名目录通常不需要移动目录中的实体
 * directory on the same {@link FileStore} will usually not require moving
 * the entries in the directory. When moving a directory requires that its 当需要移动一个目录它的实体也需要移动时，这个方法失败
 * entries be moved then this method fails (by throwing an {@code
 * IOException}). To move a <i>file tree</i> may involve copying rather  
 * than moving directories and this can be done using the {@link
 * #copy copy} method in conjunction with the {@link
 * #walkFileTree Files.walkFileTree} utility method.
 *
 * <p> The {@code options} parameter may include any of the following: options参数选项包括如下：
 *
 * <table border=1 cellpadding=5 summary="">
 * <tr> <th>Option</th> <th>Description</th> </tr>
 * <tr>
 *   <td> {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} </td> REPLACE_EXISTING：
 *   <td> If the target file exists, then the target file is replaced if it 目标文件存在时，如果不是一个非空目录，替换
 *     is not a non-empty directory. If the target file exists and is a
 *     symbolic link, then the symbolic link itself, not the target of
 *     the link, is replaced. </td>
 * </tr>
 * <tr>
 *   <td> {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} </td>
 *   <td> The move is performed as an atomic file system operation and all 执行移动作为一个文件系统的原子操作
 *     other options are ignored. If the target file exists then it is 其他选择被忽略
 *     implementation specific if the existing file is replaced or this method
 *     fails by throwing an {@link IOException}. If the move cannot be
 *     performed as an atomic file system operation then {@link
 *     AtomicMoveNotSupportedException} is thrown. This can arise, for 都会出现这种情况
 *     example, when the target location is on a different {@code FileStore} 目标位置在不同的地方
 *     and would require that the file be copied, or target location is 需要复制文件，目标位置是通过使用此对象的不同提供关联
 *     associated with a different provider to this object. </td>
 * </table>
 *
 * <p> An implementation of this interface may support additional
 * implementation specific options. 此接口的实现可能支持附加的具体实施方案
 *
 * <p> Moving a file will copy the {@link 移动文件将复制last-modified-time 到目标文件，
 * BasicFileAttributes#lastModifiedTime last-modified-time} to the target
 * file if supported by both source and target file stores. Copying of file 源和目标文件存储都支持
 * timestamps may result in precision loss精度损失. An implementation may also
 * attempt to copy other file attributes but is not required to fail if the
 * file attributes cannot be copied. When the move is performed as
 * a non-atomic operation, and an {@code IOException} is thrown, then the
 * state of the files is not defined. The original file and the target file
 * may both exist, the target file may be incomplete or some of its file
 * attributes may not been copied from the original file.
 *
 * <p> <b>Usage Examples:</b>
 * Suppose we want to rename a file to "newname", keeping the file in the
 * same directory:
 * <pre>
 *     Path source = ...
 *     Files.move(source, source.resolveSibling("newname"));
 * </pre>
 * Alternatively, suppose we want to move a file to new directory, keeping
 * the same file name, and replacing any existing file of that name in the
 * directory:
 * <pre>
 *     Path source = ...
 *     Path newdir = ...
 *     Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);
 * </pre>
 *
 * @param   source
 *          the path to the file to move
 * @param   target
 *          the path to the target file (may be associated with a different
 *          provider to the source path)
 * @param   options
 *          options specifying how the move should be done
 *
 * @return  the path to the target file
 *
 * @throws  UnsupportedOperationException
 *          if the array contains a copy option that is not supported
 * @throws  FileAlreadyExistsException
 *          if the target file exists but cannot be replaced because the
 *          {@code REPLACE_EXISTING} option is not specified <i>(optional
 *          specific exception)</i>
 * @throws  DirectoryNotEmptyException
 *          the {@code REPLACE_EXISTING} option is specified but the file
 *          cannot be replaced because it is a non-empty directory
 *          <i>(optional specific exception)</i>
 * @throws  AtomicMoveNotSupportedException
 *          if the options array contains the {@code ATOMIC_MOVE} option but
 *          the file cannot be moved as an atomic file system operation.
 * @throws  IOException
 *          if an I/O error occurs
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access to both the source and
 *          target file.
 */
public static Path move(Path source, Path target, CopyOption... options)
    throws IOException
{
    FileSystemProvider provider = provider(source);
    if (provider(target) == provider) {
        // same provider
        provider.move(source, target, options);
    } else {
        // different providers
        CopyMoveHelper.moveToForeignTarget(source, target, options);
    }
    return target;
}

```


### 其他文件操作

- Path readSymbolicLink(Path link)：读取符号链接的目标

- FileStore getFileStore(Path path)：存储的文件的位置

- boolean isSameFile(Path path, Path path2)：是否相同

- boolean isHidden(Path path)：隐藏

- String probeContentType(Path path)：文件的内容类型



```java
/**
     * Reads the target of a symbolic link <i>(optional operation)</i>. 读取符号链接的目标
     *
     * <p> If the file system supports <a href="package-summary.html#links">symbolic 如果文件系统支持符号链接时，这个方法被使用读取链接的目标
     * links</a> then this method is used to read the target of the link, failing 如果文件不是一个符号链接，失败
     * if the file is not a symbolic link. The target of the link need not exist. 链接的目标不需要存在
     * The returned {@code Path} object will be associated with the same file
     * system as {@code link}.
     *
     * @param   link
     *          the path to the symbolic link
     *
     * @return  a {@code Path} object representing the target of the link
     *
     * @throws  UnsupportedOperationException
     *          if the implementation does not support symbolic links
     * @throws  NotLinkException
     *          if the target could otherwise not be read because the file
     *          is not a symbolic link <i>(optional specific exception)</i>
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager
     *          is installed, it checks that {@code FilePermission} has been
     *          granted with the "{@code readlink}" action to read the link.
     */
    public static Path readSymbolicLink(Path link) throws IOException {
        return provider(link).readSymbolicLink(link);
    }

    /**
     * Returns the {@link FileStore} representing the file store where a file 返回FileStore对象代表文件存储的位置
     * is located.
     *
     * <p> Once a reference to the {@code FileStore} is obtained it is
     * implementation specific if operations on the returned {@code FileStore}, 一次引用到FileStore的获取，实现特定操作在
     * or {@link FileStoreAttributeView} objects obtained from it, continue FileStore或者FileStoreAttributeView
     * to depend on the existence of the file. In particular the behavior is not 取决于文件的存在
     * defined for the case that the file is deleted or moved to a different 特殊的行为不依赖于文件已经删除或者移动到不同的位置
     * file store.
     *
     * @param   path
     *          the path to the file
     *
     * @return  the file store where the file is stored 文件存储的地方
     *
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, the {@link SecurityManager#checkRead(String) checkRead}
     *          method is invoked to check read access to the file, and in
     *          addition it checks {@link RuntimePermission}<tt>
     *          ("getFileStoreAttributes")</tt>
     */
    public static FileStore getFileStore(Path path) throws IOException {
        return provider(path).getFileStore(path);
    }

    /**
     * Tests if two paths locate the same file. 两个路径是否定位到同一个文件
     *
     * <p> If both {@code Path} objects are {@link Path#equals(Object) equal}
     * then this method returns {@code true} without checking if the file exists.
     * If the two {@code Path} objects are associated with different providers
     * then this method returns {@code false}. Otherwise, this method checks if
     * both {@code Path} objects locate the same file, and depending on the
     * implementation, may require to open or access both files.
     *
     * <p> If the file system and files remain static, then this method implements 如果文件系统和文件保持静态
     * an equivalence relation for non-null {@code Paths}. 非空的等价关系
     * <ul>
     * <li>It is <i>reflexive</i>: for {@code Path} {@code f},
     *     {@code isSameFile(f,f)} should return {@code true}.
     * <li>It is <i>symmetric</i>: for two {@code Paths} {@code f} and {@code g},
     *     {@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.
     * <li>It is <i>transitive</i>: for three {@code Paths}
     *     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns
     *     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then
     *     {@code isSameFile(f,h)} will return return {@code true}.
     * </ul>
     *
     * @param   path
     *          one path to the file
     * @param   path2
     *          the other path
     *
     * @return  {@code true} if, and only if, the two paths locate the same file
     *
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, the {@link SecurityManager#checkRead(String) checkRead}
     *          method is invoked to check read access to both files.
     *
     * @see java.nio.file.attribute.BasicFileAttributes#fileKey
     */
    public static boolean isSameFile(Path path, Path path2) throws IOException {
        return provider(path).isSameFile(path, path2);
    }

    /**
     * Tells whether or not a file is considered <em>hidden</em>. The exact 文件是否隐藏，隐藏的定义准确的依赖于平台或者提供者
     * definition of hidden is platform or provider dependent. On UNIX for UNIX 文件隐藏它的名字以一段字符"."开始
     * example a file is considered to be hidden if its name begins with a
     * period character ('.'). On Windows a file is considered hidden if it
     * isn't a directory and the DOS {@link DosFileAttributes#isHidden hidden}
     * attribute is set.
     *
     * <p> Depending on the implementation this method may require to access
     * the file system to determine if the file is considered hidden.
     *
     * @param   path
     *          the path to the file to test
     *
     * @return  {@code true} if the file is considered hidden
     *
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, the {@link SecurityManager#checkRead(String) checkRead}
     *          method is invoked to check read access to the file.
     */
    public static boolean isHidden(Path path) throws IOException {
        return provider(path).isHidden(path);
    }

    // lazy loading of default and installed file type detectors 延迟加载默认和已安装的文件类型检测器
    private static class FileTypeDetectors{
        static final FileTypeDetector defaultFileTypeDetector =
            createDefaultFileTypeDetector();
        static final List<FileTypeDetector> installeDetectors =
            loadInstalledDetectors();

        // creates the default file type detector 创建默认文件类型检测器
        private static FileTypeDetector createDefaultFileTypeDetector() {
            return AccessController
                .doPrivileged(new PrivilegedAction<FileTypeDetector>() {
                    @Override public FileTypeDetector run() {
                        return sun.nio.fs.DefaultFileTypeDetector.create();
                }});
        }

        // loads all installed file type detectors 加载所有已安装的文件类型检测器
        private static List<FileTypeDetector> loadInstalledDetectors() {
            return AccessController
                .doPrivileged(new PrivilegedAction<List<FileTypeDetector>>() {
                    @Override public List<FileTypeDetector> run() {
                        List<FileTypeDetector> list = new ArrayList<>();
                        ServiceLoader<FileTypeDetector> loader = ServiceLoader
                            .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());
                        for (FileTypeDetector detector: loader) {
                            list.add(detector);
                        }
                        return list;
                }});
        }
    }

    /**
     * Probes the content type of a file. 探测文件的内容类型
     *
     * <p> This method uses the installed {@link FileTypeDetector} implementations 这个方法使用已经安装的FileTypeDetector
     * to probe the given file to determine its content type. Each file type 探测给定文件的内容类型，每个文件类型探测器的
     * detector's {@link FileTypeDetector#probeContentType probeContentType} is  probeContentType方法被执行，
     * invoked, in turn(反过来), to probe the file type 来探测文件类型. If the file is recognized then 如文件可以被识别的时，
     * the content type is returned. If the file is not recognized by any of the 内容类型返回，如果文件无法识别通过任何安装的
     * installed file type detectors then a system-default file type detector is 文件类型探测器时，系统默认的文件类型探测器被
     * invoked to guess the content type.  调用同猜测内容的类型
     *
     * <p> A given invocation of the Java virtual machine maintains a system-wide JVM给定的调用维护了一个系统范围的文件类型
     * list of file type detectors. Installed file type detectors are loaded 列表，安装文件类型探测器被加载，通过服务提供者
     * using the service-provider loading facility defined by the {@link ServiceLoader}  加载设备定义(通过ServiceLoader类)
     * class. Installed file type detectors are loaded using the system class 已安装的文件类型检测器使用system类加载
     * loader. If the system class loader cannot be found then the extension class 如果无法找到系统类加载器，使用扩展类加载器
     * loader is used; If the extension class loader cannot be found then the
     * bootstrap class loader is used. File type detectors are typically installed
     * by placing them in a JAR file on the application class path or in the
     * extension directory, the JAR file contains a provider-configuration file
     * named {@code java.nio.file.spi.FileTypeDetector} in the resource directory
     * {@code META-INF/services}, and the file lists one or more fully-qualified
     * names of concrete subclass of {@code FileTypeDetector } that have a zero
     * argument constructor. If the process of locating or instantiating the
     * installed file type detectors fails then an unspecified error is thrown.
     * The ordering that installed providers are located is implementation
     * specific.
     *
     * <p> The return value of this method is the string form of the value of a
     * Multipurpose Internet Mail Extension (MIME) content type as
     * defined by <a href="http://www.ietf.org/rfc/rfc2045.txt"><i>RFC&nbsp;2045:
     * Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet
     * Message Bodies</i></a>. The string is guaranteed to be parsable according
     * to the grammar in the RFC.
     *
     * @param   path
     *          the path to the file to probe
     *
     * @return  The content type of the file, or {@code null} if the content
     *          type cannot be determined
     *
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          If a security manager is installed and it denies an unspecified
     *          permission required by a file type detector implementation.
     */
    public static String probeContentType(Path path)
        throws IOException
    {
        // try installed file type detectors 尝试安装文件类型检测器
        for (FileTypeDetector detector: FileTypeDetectors.installeDetectors) {
            String result = detector.probeContentType(path);
            if (result != null)
                return result;
        }

        // fallback to default 调用默认
        return FileTypeDetectors.defaultFileTypeDetector.probeContentType(path);
    }

```

### 文件属性

- <V extends FileAttributeView> V getFileAttributeView(Path path,Class<V> type,LinkOption... options)： 文件属性视图

- <A extends BasicFileAttributes> A readAttributes(Path path, Class<A> type,LinkOption... options)：读取文件的属性

- Path setAttribute(Path path, String attribute, Object value, LinkOption... options):设置文件属性的值

- Object getAttribute(Path path, String attribute,LinkOption... options) :读取文件属性的值 


- Map<String,Object> readAttributes(Path path, String attributes,LinkOption... options)：将一组文件属性作为批量操作读取

- Set<PosixFilePermission> getPosixFilePermissions(Path path, LinkOption... options):文件的POSIX文件权限

- Path setPosixFilePermissions(Path path,Set<PosixFilePermission> perms):设置文件的POSIX权限

- UserPrincipal getOwner(Path path, LinkOption... options):转换文件的所有者

- Path setOwner(Path path, UserPrincipal owner):更新文件所有者

- isSymbolicLink(Path path):文件是否为符号链接

- boolean isDirectory(Path path, LinkOption... options)：是否为目录

- boolean isRegularFile(Path path, LinkOption... options)：是否为普通文件

- FileTime getLastModifiedTime(Path path, LinkOption... options)：文件的最后修改时间

- Path setLastModifiedTime(Path path, FileTime time)：更新文件最后一次修改的时间属性

- long size(Path path)：返回文件大小(以字节为单位)

- boolean exists(Path path, LinkOption... options)：是否存在

- boolean followLinks(LinkOption... options)

- notExists(Path path, LinkOption... options)：不存在

- boolean isAccessible(Path path, AccessMode... modes)：由AccessMode确认使用可行

- boolean isReadable(Path path)

- boolean isWritable(Path path)

- boolean isExecutable(Path path)

```java
/**
     * Returns a file attribute view of a given type. 返回给定类型的文件属性视图
     *
     * <p> A file attribute view provides a read-only or updatable view of a 文件属性视图提供了只读或更新的一组文件属性视图，
     * set of file attributes. This method is intended to be used where the file  这个方法打算用在文件属性视图，定义在类型安全方法，用于读取或者更新文件的属性，
     * attribute view defines type-safe methods to read or update the file
     * attributes. The {@code type} parameter is the type of the attribute view type参数是需要的属性类型视图
     * required and the method returns an instance of that type if supported. ，返回返回一个支持的类型实例
     * The {@link BasicFileAttributeView} type supports access to the basic BasicFileAttributeView 类型支持访问文件的基础属性
     * attributes of a file. Invoking this method to select a file attribute 调用这个方法选择一个文件属性视图类型，总是返回类的实例
     * view of that type will always return an instance of that class.
     *
     * <p> The {@code options} array may be used to indicate how symbolic links options属性用于检索符号链接处理
     * are handled by the resulting file attribute view for the case that the
     * file is a symbolic link. By default, symbolic links are followed. If the 默认符号链接时被允许的
     * option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then
     * symbolic links are not followed. This option is ignored by implementations
     * that do not support symbolic links.
     *
     * <p> <b>Usage Example:</b>
     * Suppose we want read or set a file's ACL, if supported:
     * <pre>
     *     Path path = ...
     *     AclFileAttributeView view = Files.getFileAttributeView(path, AclFileAttributeView.class);
     *     if (view != null) {
     *         List&lt;AclEntry&gt; acl = view.getAcl();
     *         :
     *     }
     * </pre>
     *
     * @param   <V>
     *          The {@code FileAttributeView} type
     * @param   path
     *          the path to the file
     * @param   type
     *          the {@code Class} object corresponding to the file attribute view
     * @param   options
     *          options indicating how symbolic links are handled
     *
     * @return  a file attribute view of the specified type, or {@code null} if
     *          the attribute view type is not available
     */
    public static <V extends FileAttributeView> V getFileAttributeView(Path path,
                                                                       Class<V> type,
                                                                       LinkOption... options)
    {
        return provider(path).getFileAttributeView(path, type, options);
    }

    /**
     * Reads a file's attributes as a bulk operation. 批量读取文件属性操作
     *
     * <p> The {@code type} parameter is the type of the attributes required type参数是需要的类型属性
     * and this method returns an instance of that type if supported. All 当前方法返回支持类型的一个实现
     * implementations support a basic set of file attributes and so invoking 所有的实现支持一个文件属性的基础集合
     * this method with a  {@code type} parameter of {@code
     * BasicFileAttributes.class} will not throw {@code
     * UnsupportedOperationException}.
     *
     * <p> The {@code options} array may be used to indicate how symbolic links
     * are handled for the case that the file is a symbolic link. By default,
     * symbolic links are followed and the file attribute of the final target
     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
     * NOFOLLOW_LINKS} is present then symbolic links are not followed.
     *
     * <p> It is implementation specific if all file attributes are read as an
     * atomic operation with respect to other file system operations.
     *
     * <p> <b>Usage Example:</b>
     * Suppose we want to read a file's attributes in bulk:
     * <pre>
     *    Path path = ...
     *    BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
     * </pre>
     * Alternatively, suppose we want to read file's POSIX attributes without
     * following symbolic links:
     * <pre>
     *    PosixFileAttributes attrs = Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);
     * </pre>
     *
     * @param   <A>
     *          The {@code BasicFileAttributes} type
     * @param   path
     *          the path to the file
     * @param   type
     *          the {@code Class} of the file attributes required
     *          to read
     * @param   options
     *          options indicating how symbolic links are handled
     *
     * @return  the file attributes
     *
     * @throws  UnsupportedOperationException
     *          if an attributes of the given type are not supported
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, a security manager is
     *          installed, its {@link SecurityManager#checkRead(String) checkRead}
     *          method is invoked to check read access to the file. If this
     *          method is invoked to read security sensitive attributes then the
     *          security manager may be invoke to check for additional permissions.
     */
    public static <A extends BasicFileAttributes> A readAttributes(Path path,
                                                                   Class<A> type,
                                                                   LinkOption... options)
        throws IOException
    {
        return provider(path).readAttributes(path, type, options);
    }

    /**
     * Sets the value of a file attribute. 设置文件属性的值
     *
     * <p> The {@code attribute} parameter identifies the attribute to be set attribute参数标识要设置的属性
     * and takes the form: 并采取以下形式:
     * <blockquote>
     * [<i>view-name</i><b>:</b>]<i>attribute-name</i>
     * </blockquote>
     * where square brackets [...] delineate an optional component and the
     * character {@code ':'} stands for itself.
     *
     * <p> <i>view-name</i> is the {@link FileAttributeView#name name} of a {@link
     * FileAttributeView} that identifies a set of file attributes. If not
     * specified then it defaults to {@code "basic"}, the name of the file
     * attribute view that identifies the basic set of file attributes common to
     * many file systems. <i>attribute-name</i> is the name of the attribute
     * within the set.
     *
     * <p> The {@code options} array may be used to indicate how symbolic links
     * are handled for the case that the file is a symbolic link. By default,
     * symbolic links are followed and the file attribute of the final target
     * of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKS
     * NOFOLLOW_LINKS} is present then symbolic links are not followed.
     *
     * <p> <b>Usage Example:</b>
     * Suppose we want to set the DOS "hidden" attribute:
     * <pre>
     *    Path path = ...
     *    Files.setAttribute(path, "dos:hidden", true);
     * </pre>
     *
     * @param   path
     *          the path to the file
     * @param   attribute
     *          the attribute to set
     * @param   value
     *          the attribute value
     * @param   options
     *          options indicating how symbolic links are handled
     *
     * @return  the {@code path} parameter
     *
     * @throws  UnsupportedOperationException
     *          if the attribute view is not available
     * @throws  IllegalArgumentException
     *          if the attribute name is not specified, or is not recognized, or
     *          the attribute value is of the correct type but has an
     *          inappropriate value
     * @throws  ClassCastException
     *          if the attribute value is not of the expected type or is a
     *          collection containing elements that are not of the expected
     *          type
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}
     *          method denies write access to the file. If this method is invoked
     *          to set security sensitive attributes then the security manager
     *          may be invoked to check for additional permissions.
     */
    public static Path setAttribute(Path path, String attribute, Object value,
                                    LinkOption... options)
        throws IOException
    {
        provider(path).setAttribute(path, attribute, value, options);
        return path;
    }

    /** 
     * Reads the value of a file attribute. 读取文件属性的值
     *
     * <p> The {@code attribute} parameter identifies the attribute to be read
     * and takes the form:
     * <blockquote>
     * [<i>view-name</i><b>:</b>]<i>attribute-name</i>
     * </blockquote>
     * where square brackets [...] delineate an optional component and the
     * character {@code ':'} stands for itself.
     *
     * <p> <i>view-name</i> is the {@link FileAttributeView#name name} of a {@link
     * FileAttributeView} that identifies a set of file attributes. If not
     * specified then it defaults to {@code "basic"}, the name of the file
     * attribute view that identifies the basic set of file attributes common to
     * many file systems. <i>attribute-name</i> is the name of the attribute.
     *
     * <p> The {@code options} array may be used to indicate how symbolic links
     * are handled for the case that the file is a symbolic link. By default,
     * symbolic links are followed and the file attribute of the final target
     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
     * NOFOLLOW_LINKS} is present then symbolic links are not followed.
     *
     * <p> <b>Usage Example:</b>
     * Suppose we require the user ID of the file owner on a system that
     * supports a "{@code unix}" view:
     * <pre>
     *    Path path = ...
     *    int uid = (Integer)Files.getAttribute(path, "unix:uid");
     * </pre>
     *
     * @param   path
     *          the path to the file
     * @param   attribute
     *          the attribute to read
     * @param   options
     *          options indicating how symbolic links are handled
     *
     * @return  the attribute value
     *
     * @throws  UnsupportedOperationException
     *          if the attribute view is not available
     * @throws  IllegalArgumentException
     *          if the attribute name is not specified or is not recognized
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, its {@link SecurityManager#checkRead(String) checkRead}
     *          method denies read access to the file. If this method is invoked
     *          to read security sensitive attributes then the security manager
     *          may be invoked to check for additional permissions.
     */
    public static Object getAttribute(Path path, String attribute,
                                      LinkOption... options)
        throws IOException
    {
        // only one attribute should be read
        if (attribute.indexOf('*') >= 0 || attribute.indexOf(',') >= 0)
            throw new IllegalArgumentException(attribute);
        Map<String,Object> map = readAttributes(path, attribute, options);
        assert map.size() == 1;
        String name;
        int pos = attribute.indexOf(':');
        if (pos == -1) {
            name = attribute;
        } else {
            name = (pos == attribute.length()) ? "" : attribute.substring(pos+1);
        }
        return map.get(name);
    }

    /**
     * Reads a set of file attributes as a bulk operation. 将一组文件属性作为批量操作读取
     *
     * <p> The {@code attributes} parameter identifies the attributes to be read
     * and takes the form:
     * <blockquote>
     * [<i>view-name</i><b>:</b>]<i>attribute-list</i>
     * </blockquote>
     * where square brackets [...] delineate an optional component and the
     * character {@code ':'} stands for itself.
     *
     * <p> <i>view-name</i> is the {@link FileAttributeView#name name} of a {@link
     * FileAttributeView} that identifies a set of file attributes. If not
     * specified then it defaults to {@code "basic"}, the name of the file
     * attribute view that identifies the basic set of file attributes common to
     * many file systems.
     *
     * <p> The <i>attribute-list</i> component is a comma separated list of
     * zero or more names of attributes to read. If the list contains the value
     * {@code "*"} then all attributes are read. Attributes that are not supported
     * are ignored and will not be present in the returned map. It is
     * implementation specific if all attributes are read as an atomic operation
     * with respect to other file system operations.
     *
     * <p> The following examples demonstrate possible values for the {@code
     * attributes} parameter:
     *
     * <blockquote>
     * <table border="0" summary="Possible values">
     * <tr>
     *   <td> {@code "*"} </td>
     *   <td> Read all {@link BasicFileAttributes basic-file-attributes}. </td>
     * </tr>
     * <tr>
     *   <td> {@code "size,lastModifiedTime,lastAccessTime"} </td>
     *   <td> Reads the file size, last modified time, and last access time
     *     attributes. </td>
     * </tr>
     * <tr>
     *   <td> {@code "posix:*"} </td>
     *   <td> Read all {@link PosixFileAttributes POSIX-file-attributes}. </td>
     * </tr>
     * <tr>
     *   <td> {@code "posix:permissions,owner,size"} </td>
     *   <td> Reads the POSX file permissions, owner, and file size. </td>
     * </tr>
     * </table>
     * </blockquote>
     *
     * <p> The {@code options} array may be used to indicate how symbolic links
     * are handled for the case that the file is a symbolic link. By default,
     * symbolic links are followed and the file attribute of the final target
     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
     * NOFOLLOW_LINKS} is present then symbolic links are not followed.
     *
     * @param   path
     *          the path to the file
     * @param   attributes
     *          the attributes to read
     * @param   options
     *          options indicating how symbolic links are handled
     *
     * @return  a map of the attributes returned; The map's keys are the
     *          attribute names, its values are the attribute values
     *
     * @throws  UnsupportedOperationException
     *          if the attribute view is not available
     * @throws  IllegalArgumentException
     *          if no attributes are specified or an unrecognized attributes is
     *          specified
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, its {@link SecurityManager#checkRead(String) checkRead}
     *          method denies read access to the file. If this method is invoked
     *          to read security sensitive attributes then the security manager
     *          may be invoke to check for additional permissions.
     */
    public static Map<String,Object> readAttributes(Path path, String attributes,
                                                    LinkOption... options)
        throws IOException
    {
        return provider(path).readAttributes(path, attributes, options);
    }

    /**
     * Returns a file's POSIX file permissions. 返回文件的POSIX文件权限
     *
     * <p> The {@code path} parameter is associated with a {@code FileSystem}
     * that supports the {@link PosixFileAttributeView}. This attribute view
     * provides access to file attributes commonly associated with files on file
     * systems used by operating systems that implement the Portable Operating
     * System Interface (POSIX) family of standards.
     *
     * <p> The {@code options} array may be used to indicate how symbolic links
     * are handled for the case that the file is a symbolic link. By default,
     * symbolic links are followed and the file attribute of the final target
     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
     * NOFOLLOW_LINKS} is present then symbolic links are not followed.
     *
     * @param   path
     *          the path to the file
     * @param   options
     *          options indicating how symbolic links are handled
     *
     * @return  the file permissions
     *
     * @throws  UnsupportedOperationException
     *          if the associated file system does not support the {@code
     *          PosixFileAttributeView}
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, a security manager is
     *          installed, and it denies {@link RuntimePermission}<tt>("accessUserInformation")</tt>
     *          or its {@link SecurityManager#checkRead(String) checkRead} method
     *          denies read access to the file.
     */
    public static Set<PosixFilePermission> getPosixFilePermissions(Path path,
                                                                   LinkOption... options)
        throws IOException
    {
        return readAttributes(path, PosixFileAttributes.class, options).permissions();
    }

    /** 
     * Sets a file's POSIX permissions. 设置文件的POSIX权限
     *
     * <p> The {@code path} parameter is associated with a {@code FileSystem}
     * that supports the {@link PosixFileAttributeView}. This attribute view
     * provides access to file attributes commonly associated with files on file
     * systems used by operating systems that implement the Portable Operating
     * System Interface (POSIX) family of standards.
     *
     * @param   path
     *          The path to the file
     * @param   perms
     *          The new set of permissions
     *
     * @return  The path
     *
     * @throws  UnsupportedOperationException
     *          if the associated file system does not support the {@code
     *          PosixFileAttributeView}
     * @throws  ClassCastException
     *          if the sets contains elements that are not of type {@code
     *          PosixFilePermission}
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, it denies {@link RuntimePermission}<tt>("accessUserInformation")</tt>
     *          or its {@link SecurityManager#checkWrite(String) checkWrite}
     *          method denies write access to the file.
     */
    public static Path setPosixFilePermissions(Path path,
                                               Set<PosixFilePermission> perms)
        throws IOException
    {
        PosixFileAttributeView view =
            getFileAttributeView(path, PosixFileAttributeView.class);
        if (view == null)
            throw new UnsupportedOperationException();
        view.setPermissions(perms);
        return path;
    }

    /**
     * Returns the owner of a file. 返回文件的所有者
     *
     * <p> The {@code path} parameter is associated with a file system that
     * supports {@link FileOwnerAttributeView}. This file attribute view provides
     * access to a file attribute that is the owner of the file.
     *
     * @param   path
     *          The path to the file
     * @param   options
     *          options indicating how symbolic links are handled
     *
     * @return  A user principal representing the owner of the file 表示文件所有者的用户主体
     *
     * @throws  UnsupportedOperationException
     *          if the associated file system does not support the {@code
     *          FileOwnerAttributeView}
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, it denies {@link RuntimePermission}<tt>("accessUserInformation")</tt>
     *          or its {@link SecurityManager#checkRead(String) checkRead} method
     *          denies read access to the file.
     */
    public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException {
        FileOwnerAttributeView view =
            getFileAttributeView(path, FileOwnerAttributeView.class, options);
        if (view == null)
            throw new UnsupportedOperationException();
        return view.getOwner();
    }

    /**
     * Updates the file owner. 更新文件所有者
     *
     * <p> The {@code path} parameter is associated with a file system that
     * supports {@link FileOwnerAttributeView}. This file attribute view provides
     * access to a file attribute that is the owner of the file.
     *
     * <p> <b>Usage Example:</b>
     * Suppose we want to make "joe" the owner of a file:
     * <pre>
     *     Path path = ...
     *     UserPrincipalLookupService lookupService =
     *         provider(path).getUserPrincipalLookupService();
     *     UserPrincipal joe = lookupService.lookupPrincipalByName("joe");
     *     Files.setOwner(path, joe);
     * </pre>
     *
     * @param   path
     *          The path to the file
     * @param   owner
     *          The new file owner
     *
     * @return  The path
     *
     * @throws  UnsupportedOperationException
     *          if the associated file system does not support the {@code
     *          FileOwnerAttributeView}
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, it denies {@link RuntimePermission}<tt>("accessUserInformation")</tt>
     *          or its {@link SecurityManager#checkWrite(String) checkWrite}
     *          method denies write access to the file.
     *
     * @see FileSystem#getUserPrincipalLookupService
     * @see java.nio.file.attribute.UserPrincipalLookupService
     */
    public static Path setOwner(Path path, UserPrincipal owner)
        throws IOException
    {
        FileOwnerAttributeView view =
            getFileAttributeView(path, FileOwnerAttributeView.class);
        if (view == null)
            throw new UnsupportedOperationException();
        view.setOwner(owner);
        return path;
    }

    /**
     * Tests whether a file is a symbolic link. 文件是否是一个符号链接
     *
     * <p> Where it is required to distinguish(区分) an I/O exception from the case
     * that the file is not a symbolic link then the file attributes can be
     * read with the {@link #readAttributes(Path,Class,LinkOption[])
     * readAttributes} method and the file type tested with the {@link
     * BasicFileAttributes#isSymbolicLink} method.
     *
     * @param   path  The path to the file
     *
     * @return  {@code true} if the file is a symbolic link; {@code false} if 
     *          the file does not exist, is not a symbolic link, or it cannot 文件不存在，不是一个符号链接，不能确认
     *          be determined if the file is a symbolic link or not. 是否为一个符号链接
     *
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, its {@link SecurityManager#checkRead(String) checkRead}
     *          method denies read access to the file.
     */
    public static boolean isSymbolicLink(Path path) {
        try {
            return readAttributes(path,
                                  BasicFileAttributes.class,
                                  LinkOption.NOFOLLOW_LINKS).isSymbolicLink();
        } catch (IOException ioe) {
            return false;
        }
    }

    /**
     * Tests whether a file is a directory. 文件是否是一个目录
     *
     * <p> The {@code options} array may be used to indicate how symbolic links
     * are handled for the case that the file is a symbolic link. By default,
     * symbolic links are followed and the file attribute of the final target
     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
     * NOFOLLOW_LINKS} is present then symbolic links are not followed.
     *
     * <p> Where it is required to distinguish an I/O exception from the case
     * that the file is not a directory then the file attributes can be
     * read with the {@link #readAttributes(Path,Class,LinkOption[])
     * readAttributes} method and the file type tested with the {@link
     * BasicFileAttributes#isDirectory} method.
     *
     * @param   path
     *          the path to the file to test
     * @param   options
     *          options indicating how symbolic links are handled
     *
     * @return  {@code true} if the file is a directory; {@code false} if
     *          the file does not exist, is not a directory, or it cannot
     *          be determined if the file is a directory or not.
     *
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, its {@link SecurityManager#checkRead(String) checkRead}
     *          method denies read access to the file.
     */
    public static boolean isDirectory(Path path, LinkOption... options) {
        try {
            return readAttributes(path, BasicFileAttributes.class, options).isDirectory();
        } catch (IOException ioe) {
            return false;
        }
    }

    /**
     * Tests whether a file is a regular file with opaque content.  文件是否是一个不透明的普通文件内容
     *
     * <p> The {@code options} array may be used to indicate how symbolic links
     * are handled for the case that the file is a symbolic link. By default,
     * symbolic links are followed and the file attribute of the final target
     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
     * NOFOLLOW_LINKS} is present then symbolic links are not followed.
     *
     * <p> Where it is required to distinguish an I/O exception from the case
     * that the file is not a regular file then the file attributes can be
     * read with the {@link #readAttributes(Path,Class,LinkOption[])
     * readAttributes} method and the file type tested with the {@link
     * BasicFileAttributes#isRegularFile} method.
     *
     * @param   path
     *          the path to the file
     * @param   options
     *          options indicating how symbolic links are handled
     *
     * @return  {@code true} if the file is a regular file; {@code false} if
     *          the file does not exist, is not a regular file, or it
     *          cannot be determined if the file is a regular file or not.
     *
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, its {@link SecurityManager#checkRead(String) checkRead}
     *          method denies read access to the file.
     */
    public static boolean isRegularFile(Path path, LinkOption... options) {
        try {
            return readAttributes(path, BasicFileAttributes.class, options).isRegularFile();
        } catch (IOException ioe) {
            return false;
        }
    }

    /**
     * Returns a file's last modified time. 返回文件最后修改时间
     *
     * <p> The {@code options} array may be used to indicate how symbolic links options数组参数可能被用于检索符号链接
     * are handled for the case that the file is a symbolic link. By default, 
     * symbolic links are followed and the file attribute of the final target 符号链接运行，链接的目标文件属性最终被读取
     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS
     * NOFOLLOW_LINKS} is present then symbolic links are not followed.
     *
     * @param   path
     *          the path to the file
     * @param   options
     *          options indicating how symbolic links are handled
     *
     * @return  a {@code FileTime} representing the time the file was last
     *          modified, or an implementation specific default when a time
     *          stamp to indicate the time of last modification is not supported
     *          by the file system
     *
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, its {@link SecurityManager#checkRead(String) checkRead}
     *          method denies read access to the file.
     *
     * @see BasicFileAttributes#lastModifiedTime
     */
    public static FileTime getLastModifiedTime(Path path, LinkOption... options)
        throws IOException
    {
        return readAttributes(path, BasicFileAttributes.class, options).lastModifiedTime();
    }

    /**
     * Updates a file's last modified time attribute. The file time is converted 更新文件最后一次修改的时间属性，文件的时间
     * to the epoch and precision supported by the file system. Converting from  被转换为文件系统支持的历元和精度
     * finer to coarser granularities result in precision loss. The behavior of
     * this method when attempting to set the last modified time when it is not
     * supported by the file system or is outside the range supported by the 是否支持超出范围
     * underlying file store is not defined. It may or not fail by throwing an
     * {@code IOException}.
     *
     * <p> <b>Usage Example:</b>
     * Suppose we want to set the last modified time to the current time: 设置最后的修改时间为当前时间
     * <pre>
     *    Path path = ...
     *    FileTime now = FileTime.fromMillis(System.currentTimeMillis());
     *    Files.setLastModifiedTime(path, now);
     * </pre>
     *
     * @param   path
     *          the path to the file
     * @param   time
     *          the new last modified time
     *
     * @return  the path
     *
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, the security manager's {@link
     *          SecurityManager#checkWrite(String) checkWrite} method is invoked
     *          to check write access to file
     *
     * @see BasicFileAttributeView#setTimes
     */
    public static Path setLastModifiedTime(Path path, FileTime time)
        throws IOException
    {
        getFileAttributeView(path, BasicFileAttributeView.class)
            .setTimes(time, null, null);
        return path;
    }

    /**
     * Returns the size of a file (in bytes). The size may differ from the
     * actual size on the file system due to compression, support for sparse
     * files, or other reasons. The size of files that are not {@link
     * #isRegularFile regular} files is implementation specific and
     * therefore unspecified.
     *
     * @param   path
     *          the path to the file
     *
     * @return  the file size, in bytes
     *
     * @throws  IOException
     *          if an I/O error occurs
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, its {@link SecurityManager#checkRead(String) checkRead}
     *          method denies read access to the file.
     *
     * @see BasicFileAttributes#size
     */
    public static long size(Path path) throws IOException {
        return readAttributes(path, BasicFileAttributes.class).size();
    }

     /**
     * Returns {@code false} if NOFOLLOW_LINKS is present.
     */
    private static boolean followLinks(LinkOption... options) {
        boolean followLinks = true;
        for (LinkOption opt: options) {
            if (opt == LinkOption.NOFOLLOW_LINKS) {
                followLinks = false;
                continue;
            }
            if (opt == null)
                throw new NullPointerException();
            throw new AssertionError("Should not get here");
        }
        return followLinks;
    }

    /**
     * Tests whether a file exists. 文件是否存在
     *
     * <p> The {@code options} parameter may be used to indicate how symbolic links
     * are handled for the case that the file is a symbolic link. By default,
     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS
     * NOFOLLOW_LINKS} is present then symbolic links are not followed.
     *
     * <p> Note that the result of this method is immediately outdated. If this
     * method indicates the file exists then there is no guarantee that a
     * subsequence access will succeed. Care should be taken when using this
     * method in security sensitive applications.
     *
     * @param   path
     *          the path to the file to test
     * @param   options
     *          options indicating how symbolic links are handled 如何处理符号链接的选项
     * .
     * @return  {@code true} if the file exists; {@code false} if the file does
     *          not exist or its existence cannot be determined. 它的存在是无法确定的
     *
     * @throws  SecurityException
     *          In the case of the default provider, the {@link
     *          SecurityManager#checkRead(String)} is invoked to check
     *          read access to the file.
     *
     * @see #notExists
     */
    public static boolean exists(Path path, LinkOption... options) {
        try {
            if (followLinks(options)) {
                provider(path).checkAccess(path);
            } else { 
                // attempt to read attributes without following links 尝试在不跟随链接的情况下读取属性
                readAttributes(path, BasicFileAttributes.class,
                               LinkOption.NOFOLLOW_LINKS);
            }
            // file exists
            return true;
        } catch (IOException x) {
            // does not exist or unable to determine if file exists
            return false;
        }

    }

    /**
     * Tests whether the file located by this path does not exist. This method 此路径所定位的文件不存在
     * is intended for cases where it is required to take action(采取行动) when it can be
     * confirmed that a file does not exist. 确认文件不存在
     *
     * <p> The {@code options} parameter may be used to indicate how symbolic links
     * are handled for the case that the file is a symbolic link. By default,
     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS
     * NOFOLLOW_LINKS} is present then symbolic links are not followed.
     *
     * <p> Note that this method is not the complement of the {@link #exists
     * exists} method. Where it is not possible to determine if a file exists
     * or not then both methods return {@code false}. As with the {@code exists}
     * method, the result of this method is immediately outdated. If this
     * method indicates the file does exist then there is no guarantee that a
     * subsequence attempt to create the file will succeed. Care should be taken
     * when using this method in security sensitive applications.
     *
     * @param   path
     *          the path to the file to test
     * @param   options
     *          options indicating how symbolic links are handled
     *
     * @return  {@code true} if the file does not exist; {@code false} if the
     *          file exists or its existence cannot be determined
     *
     * @throws  SecurityException
     *          In the case of the default provider, the {@link
     *          SecurityManager#checkRead(String)} is invoked to check
     *          read access to the file.
     */
    public static boolean notExists(Path path, LinkOption... options) {
        try {
            if (followLinks(options)) {
                provider(path).checkAccess(path);
            } else {
                // attempt to read attributes without following links
                readAttributes(path, BasicFileAttributes.class,
                               LinkOption.NOFOLLOW_LINKS);
            }
            // file exists
            return false; 
        } catch (NoSuchFileException x) { //出现NoSuchFileException时表示文件不存在
            // file confirmed not to exist 确认文件不存在 
            return true;
        } catch (IOException x) {
            return false;
        }
    }

    /**
     * Used by isReadbale, isWritable, isExecutable to test access to a file. 由isReadbale使用，isWritable, isexecution来测试对文件的访问
     */
    private static boolean isAccessible(Path path, AccessMode... modes) {
        try {
            provider(path).checkAccess(path, modes);
            return true;
        } catch (IOException x) {
            return false;
        }
    }

    /**
     * Tests whether a file is readable. This method checks that a file exists 文件是否可读
     * and that this Java virtual machine has appropriate privileges that would 检查文件存在，且JVM有适当的权限打开读取文件
     * allow it open the file for reading. Depending on the implementation(取决于具体实现), this
     * method may require to read file permissions, access control lists, or 读取文件权限，访问控制列表
     * other file attributes in order to check the effective access to the file. 对文件的有效访问
     * Consequently 因此；, this method may not be atomic with respect to other file 这个方法可能不是原子操作
     * system operations.
     *
     * <p> Note that the result of this method is immediately outdated, there is 方法的返回结果立即过期
     * no guarantee that a subsequent attempt to open the file for reading will 不能保证随后打开文件进行读取的尝试会成功
     * succeed (or even that it will access the same file 甚至它将访问相同的文件). Care should be taken 要小心
     * when using this method in security sensitive applications. 在安全敏感的应用程序中使用此方法
     *
     * @param   path
     *          the path to the file to check
     *
     * @return  {@code true} if the file exists and is readable; {@code false}
     *          if the file does not exist, read access would be denied because
     *          the Java virtual machine has insufficient privileges, or access
     *          cannot be determined
     *
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, the {@link SecurityManager#checkRead(String) checkRead}
     *          is invoked to check read access to the file.
     */
    public static boolean isReadable(Path path) {
        return isAccessible(path, AccessMode.READ);
    }

    /**
     * Tests whether a file is writable. This method checks that a file exists 文件可写
     * and that this Java virtual machine has appropriate privileges that would
     * allow it open the file for writing. Depending on the implementation, this
     * method may require to read file permissions, access control lists, or
     * other file attributes in order to check the effective access to the file.
     * Consequently, this method may not be atomic with respect to other file
     * system operations.
     *
     * <p> Note that result of this method is immediately outdated, there is no
     * guarantee that a subsequent attempt to open the file for writing will
     * succeed (or even that it will access the same file). Care should be taken
     * when using this method in security sensitive applications.
     *
     * @param   path
     *          the path to the file to check
     *
     * @return  {@code true} if the file exists and is writable; {@code false}
     *          if the file does not exist, write access would be denied because
     *          the Java virtual machine has insufficient privileges, or access
     *          cannot be determined
     *
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
     *          is invoked to check write access to the file.
     */
    public static boolean isWritable(Path path) {
        return isAccessible(path, AccessMode.WRITE);
    }

    /**
     * Tests whether a file is executable. This method checks that a file exists 文件是可执行的
     * and that this Java virtual machine has appropriate privileges to {@link JVM有适当的权限通过调用Runtime#exec执行文件
     * Runtime#exec execute} the file. The semantics may differ when checking 语义不同于检查访问目录
     * access to a directory. For example, on UNIX systems, checking for 
     * execute access checks 执行访问检查 that the Java virtual machine has permission to 允许
     * search the directory in order to access file or subdirectories. 搜索该目录以访问文件或子目录
     *
     * <p> Depending on the implementation, this method may require to read file
     * permissions, access control lists, or other file attributes in order to
     * check the effective access to the file. Consequently, this method may not
     * be atomic with respect to other file system operations.
     *
     * <p> Note that the result of this method is immediately outdated, there is
     * no guarantee that a subsequent attempt to execute the file will succeed
     * (or even that it will access the same file). Care should be taken when
     * using this method in security sensitive applications.
     *
     * @param   path
     *          the path to the file to check
     *
     * @return  {@code true} if the file exists and is executable; {@code false} 如果文件存在且可执行
     *          if the file does not exist, execute access would be denied because
     *          the Java virtual machine has insufficient privileges, or access
     *          cannot be determined
     *
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, the {@link SecurityManager#checkExec(String)
     *          checkExec} is invoked to check execute access to the file.
     */
    public static boolean isExecutable(Path path) {
        return isAccessible(path, AccessMode.EXECUTE);
    }
```

### 递归操作
	
遍历目录中的所有文件，并执行相关的操作

- Path walkFileTree(Path start,Set<FileVisitOption> options,int maxDepth, FileVisitor<? super Path> visitor):遍历文件树

	Path walkFileTree(Path start, FileVisitor<? super Path> visitor)


```java
/**
     * Walks a file tree.遍历文件树
     *
     * <p> This method walks a file tree rooted at a given starting file. The 以给定的起始文件为根遍历树
     * file tree traversal is <em>depth-first</em> with the given {@link 文件树遍历是深度优先通过给定的FileVisitor执行
     * FileVisitor} invoked for each file encountered. File tree traversal 对于每个遇到的文件
     * completes when all accessible files in the tree have been visited, or a 当访问了树中所有可访问的文件或者一个visit方法
     * visit method returns a result of {@link FileVisitResult#TERMINATE 返回一个TERMINATE时，遍历树完成
     * TERMINATE}. Where a visit method terminates due an {@code IOException}, 访问方法终止在一个IO异常，一个未捕获的错误
     * an uncaught error, or runtime exception, then the traversal is terminated 运行时异常时，遍历终止
     * and the error or exception is propagated to the caller of this method. 错误或者异常传播给方法调用者
     *
     * <p> For each file encountered this method attempts to read its {@link 对于每一个遇到的文件，这个方法尝试读取它的
     * java.nio.file.attribute.BasicFileAttributes}. If the file is not a BasicFileAttributes属性，如果文件不是一个目录
     * directory then the {@link FileVisitor#visitFile visitFile} method is 时，visitFile方法被调用通过文件文件属性
     * invoked with the file attributes. If the file attributes cannot be read, 如果文件属性不能读取，由于一个 I/O异常
     * due to an I/O exception, then the {@link FileVisitor#visitFileFailed 时 visitFileFailed方法被执行通过IO异常
     * visitFileFailed} method is invoked with the I/O exception.
     *
     * <p> Where the file is a directory, and the directory could not be opened, 文件是个目录且文件不能打开时，
     * then the {@code visitFileFailed} method is invoked with the I/O exception, visitFileFailed方法时通过IO调用
     * after which, the file tree walk continues, by default, at the next 文件树遍历继续，默认继续下一个兄弟目录
     * <em>sibling</em> of the directory.
     *
     * <p> Where the directory is opened successfully, then the entries in the 文件成功打开时，目录中的实体机它们的后代将
     * directory, and their <em>descendants</em> are visited. When all entries 被访问，当所有的实体已经被方法或者在遍历时发生
     * have been visited, or an I/O error occurs during iteration of the IO error 目录关闭，且postVisitDirectory方法执行
     * directory, then the directory is closed and the visitor's {@link
     * FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.
     * The file tree walk then continues, by default, at the next <em>sibling</em>
     * of the directory.
     *
     * <p> By default, symbolic links are not automatically followed by this 符号链接不自动跟踪
     * method. If the {@code options} parameter contains the {@link
     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are 如果options参数包含FOLLOW_LINKS时，
     * followed. When following links, and the attributes of the target cannot 符号链接跟踪，当运行链接时，目标属性不能被读取
     * be read, then this method attempts to get the {@code BasicFileAttributes} 这个方法尝试获取链接的
     * of the link. If they can be read then the {@code visitFile} method is BasicFileAttributes属性，如果它们可以读取时。
     * invoked with the attributes of the link (otherwise the {@code visitFileFailed} visitFile方法调用，通过链接的属性
     * method is invoked as specified above).
     *
     * <p> If the {@code options} parameter contains the {@link 如果options参数包含FOLLOW_LINKS
     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps  选项时，这个方法保持目标访问的追踪
     * track of directories visited so that cycles can be detected. A cycle  这样就可以检测到循环
     * arises when there is an entry in a directory that is an ancestor of the 一个循环出现时，当祖先目录中的一个实体
     * directory. Cycle detection is done by recording the {@link 循环检测是通过 file-key} 记录目录
     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,
     * or if file keys are not available, by invoking the {@link #isSameFile 或者文件keys不可达时，isSameFile方法将test
     * isSameFile} method to test if a directory is the same file as an 目录是一个相同的文祖先件
     * ancestor. When a cycle is detected it is treated as an I/O error, and the 当检测到一个周期时，它被视为I/O错误
     * {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with visitFileFailed通过FileSystemLoopException实例调用
     * an instance of {@link FileSystemLoopException}.
     *
     * <p> The {@code maxDepth} parameter is the maximum number of levels of maxDepth参数目录访问的最大等级
     * directories to visit. A value of {@code 0} means that only the starting 0意味着只访问开始文件
     * file is visited, unless denied by the security manager. A value of 除非定义了security manager.
     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all  MAX_VALUE被使用检索所有等级
     * levels should be visited. The {@code visitFile} method is invoked for all  visitFile方法对于所有文件调用
     * files, including directories, encountered at {@code maxDepth}, unless the 包括目录，遇到的maxDepth，除非文件的基础
     * basic file attributes cannot be read, in which case the {@code 属性不能读取，在这种情况下visitFileFailed方法调用
     * visitFileFailed} method is invoked.
     *
     * <p> If a visitor returns a result of {@code null} then {@code 如果一个visitor返回一个null时，NullPointerException抛出
     * NullPointerException} is thrown.
     *
     * <p> When a security manager is installed and it denies access to a file a security manager 安装时，它拒绝访问文件或目录
     * (or directory), then it is ignored and the visitor is not invoked for
     * that file (or directory).
     *
     * @param   start
     *          the starting file
     * @param   options
     *          options to configure the traversal 配置遍历的选项
     * @param   maxDepth
     *          the maximum number of directory levels to visit 要访问的目录级别的最大数目
     * @param   visitor
     *          the file visitor to invoke for each file 要为每个文件调用的文件访问器
     *
     * @return  the starting file
     *
     * @throws  IllegalArgumentException
     *          if the {@code maxDepth} parameter is negative
     * @throws  SecurityException
     *          If the security manager denies access to the starting file.
     *          In the case of the default provider, the {@link
     *          SecurityManager#checkRead(String) checkRead} method is invoked
     *          to check read access to the directory.
     * @throws  IOException
     *          if an I/O error is thrown by a visitor method
     */
    public static Path walkFileTree(Path start,
                                    Set<FileVisitOption> options,
                                    int maxDepth,
                                    FileVisitor<? super Path> visitor)
        throws IOException
    {
        /**
         * Create a FileTreeWalker to walk the file tree, invoking the visitor 创建一个FileTreeWalker用于遍历文件树
         * for each event. 对于每个事件，执行访问器
         */
        try (FileTreeWalker walker = new FileTreeWalker(options, maxDepth)) {
            FileTreeWalker.Event ev = walker.walk(start); //遍历
            do {
                FileVisitResult result; //文件访问器结果
                switch (ev.type()) {  //时间类型
                    case ENTRY :  //进入一个目录
                        IOException ioe = ev.ioeException();
                        if (ioe == null) {
                            assert ev.attributes() != null;
                            result = visitor.visitFile(ev.file(), ev.attributes()); //执行文件访问其他访问文件
                        } else {
                            result = visitor.visitFileFailed(ev.file(), ioe); //执行失败操作
                        }
                        break;

                    case START_DIRECTORY : //开始一个目录
                        result = visitor.preVisitDirectory(ev.file(), ev.attributes()); //在访问目录中的项之前为目录调用

                        // if SKIP_SIBLINGS and SKIP_SUBTREE is returned then 忽略兄弟和子孙
                        // there shouldn't be any more events for the current
                        // directory.
                        if (result == FileVisitResult.SKIP_SUBTREE ||
                            result == FileVisitResult.SKIP_SIBLINGS)
                            walker.pop(); //弹出目录节点
                        break;

                    case END_DIRECTORY : //结束一个文件目录
                        result = visitor.postVisitDirectory(ev.file(), ev.ioeException());//目录中的所有文件访问完成时调用

                        // SKIP_SIBLINGS is a no-op for postVisitDirectory
                        if (result == FileVisitResult.SKIP_SIBLINGS)
                            result = FileVisitResult.CONTINUE;
                        break;

                    default :
                        throw new AssertionError("Should not get here");
                }

                if (Objects.requireNonNull(result) != FileVisitResult.CONTINUE) { 
                    if (result == FileVisitResult.TERMINATE) { //终止
                        break;
                    } else if (result == FileVisitResult.SKIP_SIBLINGS) {
                        walker.skipRemainingSiblings();
                    }
                }
                ev = walker.next();//获取下一个
            } while (ev != null);
        }

        return start;
    }

    /**
     * Walks a file tree.
     *
     * <p> This method works as if invoking it were equivalent to evaluating the
     * expression:
     * <blockquote><pre>
     * walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)
     * </pre></blockquote>
     * In other words, it does not follow symbolic links, and visits all levels
     * of the file tree.
     *
     * @param   start
     *          the starting file
     * @param   visitor
     *          the file visitor to invoke for each file
     *
     * @return  the starting file
     *
     * @throws  SecurityException
     *          If the security manager denies access to the starting file.
     *          In the case of the default provider, the {@link
     *          SecurityManager#checkRead(String) checkRead} method is invoked
     *          to check read access to the directory.
     * @throws  IOException
     *          if an I/O error is thrown by a visitor method
     */
    public static Path walkFileTree(Path start, FileVisitor<? super Path> visitor)
        throws IOException
    {
        return walkFileTree(start,
                            EnumSet.noneOf(FileVisitOption.class),
                            Integer.MAX_VALUE,
                            visitor);
    }


```

### 简单实用方法

- BufferedReader newBufferedReader(Path path, Charset cs):创建BufferedReader字符缓冲输入流，用于缓冲字符读取
  	BufferedReader newBufferedReader(Path path)

- BufferedWriter newBufferedWriter(Path path, Charset cs,OpenOption... options)：创建字符缓冲输出流，用于缓冲字符写入
	BufferedWriter newBufferedWriter(Path path, OpenOption... options)

- long copy(InputStream in, Path target, CopyOption... options)：将输入流中的所有字节复制到文件中
	long copy(Path source, OutputStream out)

- byte[] readAllBytes(Path path)：从文件中读取所有字节

- List<String> readAllLines(Path path, Charset cs)：从文件中读取所有行
	List<String> readAllLines(Path path)

- Path write(Path path, byte[] bytes, OpenOption... options)：将字节写入文件

	Path write(Path path, Iterable<? extends CharSequence> lines,Charset cs, OpenOption... options)：将文本行写入文件
	Path write(Path path,Iterable<? extends CharSequence> lines,OpenOption... options)

```java

// buffer size used for reading and writing 用于读写的缓冲区大小
private static final int BUFFER_SIZE = 8192;

/**
 * Opens a file for reading, returning a {@code BufferedReader} that may be 打开文件用于读取，返回一个BufferedReader
 * used to read text from the file in an efficient manner. Bytes from the 被用来读取文本以高效的方式，从文件获取的字节
 * file are decoded into characters using the specified charset. Reading 使用指定的字符集进行解码
 * commences at the beginning of the file. 从文件的开始读取
 *
 * <p> The {@code Reader} methods that read from the file throw {@code
 * IOException} if a malformed or unmappable byte sequence is read. 果读取格式错误或无法映射的字节序列
 *
 * @param   path
 *          the path to the file
 * @param   cs
 *          the charset to use for decoding
 *
 * @return  a new buffered reader, with default buffer size, to read text 使用默认的缓冲大小
 *          from the file
 *
 * @throws  IOException
 *          if an I/O error occurs opening the file
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the file.
 *
 * @see #readAllLines
 */
public static BufferedReader newBufferedReader(Path path, Charset cs)
    throws IOException
{
    CharsetDecoder decoder = cs.newDecoder(); //字符集解码
    Reader reader = new InputStreamReader(newInputStream(path), decoder); //创建字符输入流
    return new BufferedReader(reader);
}

/**
 * Opens a file for reading, returning a {@code BufferedReader} to read text
 * from the file in an efficient manner. Bytes from the file are decoded into
 * characters using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset
 * charset}.
 *
 * <p> This method works as if invoking it were equivalent to evaluating the
 * expression:
 * <pre>{@code
 * Files.newBufferedReader(path, StandardCharsets.UTF_8)
 * }</pre>
 *
 * @param   path
 *          the path to the file
 *
 * @return  a new buffered reader, with default buffer size, to read text
 *          from the file
 *
 * @throws  IOException
 *          if an I/O error occurs opening the file
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the file.
 *
 * @since 1.8
 */
public static BufferedReader newBufferedReader(Path path) throws IOException {
    return newBufferedReader(path, StandardCharsets.UTF_8);
}

/**
 * Opens or creates a file for writing, returning a {@code BufferedWriter}
 * that may be used to write text to the file in an efficient manner.
 * The {@code options} parameter specifies how the the file is created or
 * opened. If no options are present then this method works as if the {@link
 * StandardOpenOption#CREATE CREATE}, {@link
 * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
 * StandardOpenOption#WRITE WRITE} options are present. In other words, it
 * opens the file for writing, creating the file if it doesn't exist, or
 * initially truncating an existing {@link #isRegularFile regular-file} to
 * a size of {@code 0} if it exists.
 *
 * <p> The {@code Writer} methods to write text throw {@code IOException}
 * if the text cannot be encoded using the specified charset.
 *
 * @param   path
 *          the path to the file
 * @param   cs
 *          the charset to use for encoding
 * @param   options
 *          options specifying how the file is opened
 *
 * @return  a new buffered writer, with default buffer size, to write text
 *          to the file
 *
 * @throws  IOException
 *          if an I/O error occurs opening or creating the file
 * @throws  UnsupportedOperationException
 *          if an unsupported option is specified
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access to the file.
 *
 * @see #write(Path,Iterable,Charset,OpenOption[])
 */
public static BufferedWriter newBufferedWriter(Path path, Charset cs,
                                               OpenOption... options)
    throws IOException
{
    CharsetEncoder encoder = cs.newEncoder();
    Writer writer = new OutputStreamWriter(newOutputStream(path, options), encoder);
    return new BufferedWriter(writer);
}

/**
 * Opens or creates a file for writing, returning a {@code BufferedWriter}
 * to write text to the file in an efficient manner. The text is encoded
 * into bytes for writing using the {@link StandardCharsets#UTF_8 UTF-8}
 * {@link Charset charset}.
 *
 * <p> This method works as if invoking it were equivalent to evaluating the
 * expression:
 * <pre>{@code
 * Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)
 * }</pre>
 *
 * @param   path
 *          the path to the file
 * @param   options
 *          options specifying how the file is opened
 *
 * @return  a new buffered writer, with default buffer size, to write text
 *          to the file
 *
 * @throws  IOException
 *          if an I/O error occurs opening or creating the file
 * @throws  UnsupportedOperationException
 *          if an unsupported option is specified
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access to the file.
 *
 * @since 1.8
 */
public static BufferedWriter newBufferedWriter(Path path, OpenOption... options) throws IOException {
    return newBufferedWriter(path, StandardCharsets.UTF_8, options);
}

/**
 * Reads all bytes from an input stream and writes them to an output stream.
 */
private static long copy(InputStream source, OutputStream sink)
    throws IOException
{
    long nread = 0L;
    byte[] buf = new byte[BUFFER_SIZE];
    int n;
    while ((n = source.read(buf)) > 0) {
        sink.write(buf, 0, n);
        nread += n;
    }
    return nread;
}

/**
 * Copies all bytes from an input stream to a file. On return, the input
 * stream will be at end of stream.
 *
 * <p> By default, the copy fails if the target file already exists or is a
 * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING
 * REPLACE_EXISTING} option is specified, and the target file already exists,
 * then it is replaced if it is not a non-empty directory. If the target
 * file exists and is a symbolic link, then the symbolic link is replaced.
 * In this release, the {@code REPLACE_EXISTING} option is the only option
 * required to be supported by this method. Additional options may be
 * supported in future releases.
 *
 * <p>  If an I/O error occurs reading from the input stream or writing to
 * the file, then it may do so after the target file has been created and
 * after some bytes have been read or written. Consequently the input
 * stream may not be at end of stream and may be in an inconsistent state.
 * It is strongly recommended that the input stream be promptly closed if an
 * I/O error occurs.
 *
 * <p> This method may block indefinitely reading from the input stream (or
 * writing to the file). The behavior for the case that the input stream is
 * <i>asynchronously closed</i> or the thread interrupted during the copy is
 * highly input stream and file system provider specific and therefore not
 * specified.
 *
 * <p> <b>Usage example</b>: Suppose we want to capture a web page and save
 * it to a file:
 * <pre>
 *     Path path = ...
 *     URI u = URI.create("http://java.sun.com/");
 *     try (InputStream in = u.toURL().openStream()) {
 *         Files.copy(in, path);
 *     }
 * </pre>
 *
 * @param   in
 *          the input stream to read from
 * @param   target
 *          the path to the file
 * @param   options
 *          options specifying how the copy should be done
 *
 * @return  the number of bytes read or written
 *
 * @throws  IOException
 *          if an I/O error occurs when reading or writing
 * @throws  FileAlreadyExistsException
 *          if the target file exists but cannot be replaced because the
 *          {@code REPLACE_EXISTING} option is not specified <i>(optional
 *          specific exception)</i>
 * @throws  DirectoryNotEmptyException
 *          the {@code REPLACE_EXISTING} option is specified but the file
 *          cannot be replaced because it is a non-empty directory
 *          <i>(optional specific exception)</i>     *
 * @throws  UnsupportedOperationException
 *          if {@code options} contains a copy option that is not supported
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access to the file. Where the
 *          {@code REPLACE_EXISTING} option is specified, the security
 *          manager's {@link SecurityManager#checkDelete(String) checkDelete}
 *          method is invoked to check that an existing file can be deleted.
 */
public static long copy(InputStream in, Path target, CopyOption... options)
    throws IOException
{
    // ensure not null before opening file
    Objects.requireNonNull(in);

    // check for REPLACE_EXISTING
    boolean replaceExisting = false;
    for (CopyOption opt: options) {
        if (opt == StandardCopyOption.REPLACE_EXISTING) {
            replaceExisting = true;
        } else {
            if (opt == null) {
                throw new NullPointerException("options contains 'null'");
            }  else {
                throw new UnsupportedOperationException(opt + " not supported");
            }
        }
    }

    // attempt to delete an existing file
    SecurityException se = null;
    if (replaceExisting) {
        try {
            deleteIfExists(target);
        } catch (SecurityException x) {
            se = x;
        }
    }

    // attempt to create target file. If it fails with
    // FileAlreadyExistsException then it may be because the security
    // manager prevented us from deleting the file, in which case we just
    // throw the SecurityException.
    OutputStream ostream;
    try {
        ostream = newOutputStream(target, StandardOpenOption.CREATE_NEW,
                                          StandardOpenOption.WRITE);
    } catch (FileAlreadyExistsException x) {
        if (se != null)
            throw se;
        // someone else won the race and created the file
        throw x;
    }

    // do the copy
    try (OutputStream out = ostream) {
        return copy(in, out);
    }
}

/**
 * Copies all bytes from a file to an output stream.
 *
 * <p> If an I/O error occurs reading from the file or writing to the output
 * stream, then it may do so after some bytes have been read or written.
 * Consequently the output stream may be in an inconsistent state. It is
 * strongly recommended that the output stream be promptly closed if an I/O
 * error occurs.
 *
 * <p> This method may block indefinitely writing to the output stream (or
 * reading from the file). The behavior for the case that the output stream
 * is <i>asynchronously closed</i> or the thread interrupted during the copy
 * is highly output stream and file system provider specific and therefore
 * not specified.
 *
 * <p> Note that if the given output stream is {@link java.io.Flushable}
 * then its {@link java.io.Flushable#flush flush} method may need to invoked
 * after this method completes so as to flush any buffered output.
 *
 * @param   source
 *          the  path to the file
 * @param   out
 *          the output stream to write to
 *
 * @return  the number of bytes read or written
 *
 * @throws  IOException
 *          if an I/O error occurs when reading or writing
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the file.
 */
public static long copy(Path source, OutputStream out) throws IOException {
    // ensure not null before opening file
    Objects.requireNonNull(out);

    try (InputStream in = newInputStream(source)) {
        return copy(in, out);
    }
}

/**
 * The maximum size of array to allocate. 要分配的数组的最大大小
 * Some VMs reserve some header words in an array. 一些vm在数组中保留一些头信息
 * Attempts to allocate larger arrays may result in 尝试分配更大的数组可能会导致OutOfMemoryError
 * OutOfMemoryError: Requested array size exceeds VM limit 请求的数组大小超过VM限制
 */
private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;

/**
 * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint 从输入流中读取所有字节，使用初始大小作为关于流将有多少字节的提示
 * about how many bytes the stream will have.
 *
 * @param   source
 *          the input stream to read from
 * @param   initialSize
 *          the initial size of the byte array to allocate 要分配的字节数组的初始大小
 *
 * @return  a byte array containing the bytes read from the file 包含从文件中读取的字节的字节数组
 *
 * @throws  IOException
 *          if an I/O error occurs reading from the stream
 * @throws  OutOfMemoryError
 *          if an array of the required size cannot be allocated 如果无法分配所需大小的数组
 */
private static byte[] read(InputStream source, int initialSize) throws IOException {
    int capacity = initialSize;
    byte[] buf = new byte[capacity]; //创建固定大小的字节数组
    int nread = 0;
    int n;
    for (;;) {
        // read to EOF which may read more or less than initialSize (eg: file 读取到的文件结束符可能大于或小于初始大小
        // is truncated while we are reading) 文件在读取时截断
        while ((n = source.read(buf, nread, capacity - nread)) > 0)//读取文件的大小
            nread += n; 

        // if last call to source.read() returned -1, we are done 如果最后一次调用source.read()返回-
        // otherwise, try to read one more byte试着多读一个字节; if that failed we're done too 
        if (n < 0 || (n = source.read()) < 0)
            break;

        // one more byte was read 又读取了一个字节;  need to allocate a larger buffer 需要分配更大的缓冲区
        if (capacity <= MAX_BUFFER_SIZE - capacity) {
            capacity = Math.max(capacity << 1, BUFFER_SIZE);
        } else {
            if (capacity == MAX_BUFFER_SIZE)
                throw new OutOfMemoryError("Required array size too large");
            capacity = MAX_BUFFER_SIZE;
        }
        buf = Arrays.copyOf(buf, capacity);
        buf[nread++] = (byte)n;
    }
    return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);
}

/**
 * Reads all the bytes from a file. The method ensures that the file is 从文件中读物所有字节
 * closed when all bytes have been read or an I/O error, or other runtime
 * exception, is thrown.
 *
 * <p> Note that this method is intended for simple cases where it is
 * convenient to read all bytes into a byte array 字节数组. It is not intended for
 * reading in large files.
 *
 * @param   path
 *          the path to the file
 *
 * @return  a byte array containing the bytes read from the file
 *
 * @throws  IOException
 *          if an I/O error occurs reading from the stream
 * @throws  OutOfMemoryError
 *          if an array of the required size cannot be allocated, for 如果无法分配所需大小的数组，抛出OutOfMemoryError
 *          example the file is larger that {@code 2GB}
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the file.
 */
public static byte[] readAllBytes(Path path) throws IOException {
    try (SeekableByteChannel sbc = Files.newByteChannel(path); //创建可查找的直接管道
         InputStream in = Channels.newInputStream(sbc)) { //创建输入流
        long size = sbc.size();
        if (size > (long)MAX_BUFFER_SIZE)
            throw new OutOfMemoryError("Required array size too large");

        return read(in, (int)size);
    }
}

/**
 * Read all lines from a file. This method ensures that the file is 从文件中读取每一行，这个方法确保文件关闭，当所有的字节已经读或者抛出IO错误，运行时异常
 * closed when all bytes have been read or an I/O error, or other runtime
 * exception, is thrown. Bytes from the file are decoded into characters 从文件读取的字节使用指定的字符集解码
 * using the specified charset.
 *
 * <p> This method recognizes the following as line terminators: 此方法将以下内容识别为行终止符
 * <ul>
 *   <li> <code>&#92;u000D</code> followed by <code>&#92;u000A</code>,
 *     CARRIAGE RETURN followed by LINE FEED </li>
 *   <li> <code>&#92;u000A</code>, LINE FEED </li>
 *   <li> <code>&#92;u000D</code>, CARRIAGE RETURN </li>
 * </ul>
 * <p> Additional Unicode line terminators may be recognized in future
 * releases. 将来可能会识别出其他Unicode行终止符版本
 *
 * <p> Note that this method is intended for simple cases where it is 这个方法适用于简单的情况，方便在一次操作中读取所有行
 * convenient to read all lines in a single operation. It is not intended
 * for reading in large files. 不适应与读取大文件
 *
 * @param   path
 *          the path to the file
 * @param   cs
 *          the charset to use for decoding
 *
 * @return  the lines from the file as a {@code List}; whether the {@code 返回文件的所有行作为一个集合
 *          List} is modifiable(可变) or not is implementation dependent and
 *          therefore not specified
 *
 * @throws  IOException
 *          if an I/O error occurs reading from the file or a malformed or
 *          unmappable byte sequence is read
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the file.
 *
 * @see #newBufferedReader
 */
public static List<String> readAllLines(Path path, Charset cs) throws IOException {
    try (BufferedReader reader = newBufferedReader(path, cs)) { //创建缓存区字符读取
        List<String> result = new ArrayList<>();
        for (;;) {
            String line = reader.readLine(); //读取每一行
            if (line == null)
                break;
            result.add(line);
        }
        return result;
    }
}

/**
 * Read all lines from a file. Bytes from the file are decoded into characters  从文件中读取所有行
 * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
 *
 * <p> This method works as if invoking it were equivalent to evaluating the
 * expression:
 * <pre>{@code
 * Files.readAllLines(path, StandardCharsets.UTF_8)
 * }</pre>
 *
 * @param   path
 *          the path to the file
 *
 * @return  the lines from the file as a {@code List}; whether the {@code
 *          List} is modifiable or not is implementation dependent and
 *          therefore not specified
 *
 * @throws  IOException
 *          if an I/O error occurs reading from the file or a malformed or
 *          unmappable byte sequence is read
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkRead(String) checkRead}
 *          method is invoked to check read access to the file.
 *
 * @since 1.8
 */
public static List<String> readAllLines(Path path) throws IOException {
    return readAllLines(path, StandardCharsets.UTF_8);
}

/**
 * Writes bytes to a file. The {@code options} parameter specifies how the 写字节到文件，options参数指定怎样创建或者打开文件
 * the file is created or opened. If no options are present then this method 
 * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link
 * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
 * StandardOpenOption#WRITE WRITE} options are present. In other words, it 打开文件用于写入，如果不存在创建，或者
 * opens the file for writing, creating the file if it doesn't exist, or 
 * initially truncating an existing {@link #isRegularFile regular-file 普通} to 一开始删除，如果存在普通文件的大小为0
 * a size of {@code 0}. All bytes in the byte array are written to the file. 所有的字节写入文件
 * The method ensures that the file is closed when all bytes have been 当所有字节已经写入(或者抛出IO错误或者运行时异常) 确保关闭文件，
 * written (or an I/O error or other runtime exception is thrown). If an I/O 如果发现IO错误时，文件创建或截断或者一些字节已经写入文件
 * error occurs then it may do so after(之后可能会这样做) the file has created or truncated,
 * or after some bytes have been written to the file.
 *
 * <p> <b>Usage example</b>: By default the method creates a new file or 默认方法创建一个文件或者从谢存在的文件
 * overwrites an existing file. Suppose you instead want to append bytes  假设您想要添加字节到存在的文件
 * to an existing file:
 * <pre>
 *     Path path = ...
 *     byte[] bytes = ...
 *     Files.write(path, bytes, StandardOpenOption.APPEND);
 * </pre>
 *
 * @param   path
 *          the path to the file 文件的路径
 * @param   bytes
 *          the byte array with the bytes to write 包含要写入的字节的字节数组
 * @param   options
 *          options specifying how the file is opened 指定如何打开文件的选项
 *
 * @return  the path
 *
 * @throws  IOException
 *          if an I/O error occurs writing to or creating the file
 * @throws  UnsupportedOperationException
 *          if an unsupported option is specified
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access to the file.
 */
public static Path write(Path path, byte[] bytes, OpenOption... options)
    throws IOException
{
    // ensure bytes is not null before opening file 在打开文件之前确保字节不为空
    Objects.requireNonNull(bytes);

    try (OutputStream out = Files.newOutputStream(path, options)) { //JDK 1.7提供的自动关闭资源
        int len = bytes.length;
        int rem = len;
        while (rem > 0) {
            int n = Math.min(rem, BUFFER_SIZE); //一次性写入的长度
            out.write(bytes, (len-rem), n); //写入
            rem -= n;
        }
    }
    return path;
}

/**
 * Write lines of text to a file. Each line is a char sequence and is
 * written to the file in sequence with each line terminated by the
 * platform's line separator, as defined by the system property {@code
 * line.separator}. Characters are encoded into bytes using the specified
 * charset.
 *
 * <p> The {@code options} parameter specifies how the the file is created
 * or opened. If no options are present then this method works as if the
 * {@link StandardOpenOption#CREATE CREATE}, {@link
 * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link
 * StandardOpenOption#WRITE WRITE} options are present. In other words, it
 * opens the file for writing, creating the file if it doesn't exist, or
 * initially truncating an existing {@link #isRegularFile regular-file} to
 * a size of {@code 0}. The method ensures that the file is closed when all
 * lines have been written (or an I/O error or other runtime exception is
 * thrown). If an I/O error occurs then it may do so after the file has
 * created or truncated, or after some bytes have been written to the file.
 *
 * @param   path
 *          the path to the file 文件path
 * @param   lines
 *          an object to iterate over the char sequences 遍历字符序列的对象
 * @param   cs
 *          the charset to use for encoding 用于编码的字符集
 * @param   options
 *          options specifying how the file is opened 指定如何打开文件的选项
 *
 * @return  the path
 *
 * @throws  IOException
 *          if an I/O error occurs writing to or creating the file, or the
 *          text cannot be encoded using the specified charset
 * @throws  UnsupportedOperationException
 *          if an unsupported option is specified
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access to the file.
 */
public static Path write(Path path, Iterable<? extends CharSequence> lines,
                         Charset cs, OpenOption... options)
    throws IOException
{
    // ensure lines is not null before opening file
    Objects.requireNonNull(lines);
    CharsetEncoder encoder = cs.newEncoder(); //为这个字符集构造一个新的编码器
    OutputStream out = newOutputStream(path, options); //创建输出流
    try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, encoder))) { //创建字符输出流，缓冲字符
        for (CharSequence line: lines) { 
            writer.append(line); //添加行
            writer.newLine(); //新建行
        }
    }
    return path;
}

/**
 * Write lines of text to a file. Characters are encoded into bytes using 写文本行到文件，Characters编码使用UTF_8
 * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.
 *
 * <p> This method works as if invoking it were equivalent to evaluating the
 * expression:
 * <pre>{@code
 * Files.write(path, lines, StandardCharsets.UTF_8, options);
 * }</pre>
 *
 * @param   path
 *          the path to the file
 * @param   lines
 *          an object to iterate over the char sequences
 * @param   options
 *          options specifying how the file is opened
 *
 * @return  the path
 *
 * @throws  IOException
 *          if an I/O error occurs writing to or creating the file, or the
 *          text cannot be encoded as {@code UTF-8}
 * @throws  UnsupportedOperationException
 *          if an unsupported option is specified
 * @throws  SecurityException
 *          In the case of the default provider, and a security manager is
 *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}
 *          method is invoked to check write access to the file.
 *
 * @since 1.8
 */
public static Path write(Path path,
                         Iterable<? extends CharSequence> lines,
                         OpenOption... options)
    throws IOException
{
    return write(path, lines, StandardCharsets.UTF_8, options);
}

```

### Stream APIs

- Stream<Path> list(Path dir)：获取目录中的元素，不进行递归操作，即仅获取目录下的文件

- Stream<Path> walk(Path start,int maxDepth,FileVisitOption... options)：遍历以给定起始文件为根的文件树

	Stream<Path> walk(Path start, FileVisitOption... options)

- Stream<Path> find(Path start, int maxDepth,BiPredicate<Path, BasicFileAttributes> matcher,FileVisitOption... options):在以给定起始点为根的文件树中查找文件文件，实用BiPredicate<Path, BasicFileAttributes>对文件进行删除操作

-  Stream<String> lines(Path path, Charset cs):以Stream的形式读取文件中的所有行
	Stream<String> lines(Path path)

```java
/**
     * Return a lazily populated {@code Stream}, the elements of
     * which are the entries in the directory. 目录中的实体 The listing is not recursive. 列表不是递归的
     *
     * <p> The elements of the stream are {@link Path} objects that are 流中的元素对象Path从Path#resolve(Path)解析获取
     * obtained as if by {@link Path#resolve(Path) resolving} the name of the
     * directory entry against {@code dir}. Some file systems maintain special 一些文件系统维护到目录的特殊链接它自己和目录的父目录
     * links to the directory itself and the directory's parent directory.
     * Entries representing these links are not included. 不包括表示这些链接的条目
     *
     * <p> The stream is <i>weakly consistent</i>. It is thread safe but does Stream是弱一直性，线程是安全的，但是Stream迭代时不冻结目录
     * not freeze the directory while iterating, so it may (or may not)
     * reflect updates to the directory that occur after returning from this 在这个方法返回时，将更新反映到目录
     * method.
     *
     * <p> The returned stream encapsulates a {@link DirectoryStream}. 返回的流封装在DirectoryStream，如果需要及时处理文件系统资源
     * If timely disposal of file system resources is required, the
     * {@code try}-with-resources construct should be used to ensure that the try-with-resources 结构将被使用，确保流的close方法调用，在流操作完成
     * stream's {@link Stream#close close} method is invoked after the stream
     * operations are completed.
     *
     * <p> Operating on a closed stream behaves as if the end of stream 在一个封闭的流上操作就好像流的末端已经到达
     * has been reached. Due to read-ahead, one or more elements may be 由于预读,一个或多个元素可能返回，在流关闭后
     * returned after the stream has been closed.
     *
     * <p> If an {@link IOException} is thrown when accessing the directory
     * after this method has returned, it is wrapped in an {@link
     * UncheckedIOException} which will be thrown from the method that caused
     * the access to take place.
     *
     * @param   dir  The path to the directory
     *
     * @return  The {@code Stream} describing the content of the
     *          directory
     *
     * @throws  NotDirectoryException
     *          if the file could not otherwise be opened because it is not
     *          a directory <i>(optional specific exception)</i>
     * @throws  IOException
     *          if an I/O error occurs when opening the directory
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, the {@link SecurityManager#checkRead(String) checkRead}
     *          method is invoked to check read access to the directory.
     *
     * @see     #newDirectoryStream(Path)
     * @since   1.8
     */
    public static Stream<Path> list(Path dir) throws IOException {
        DirectoryStream<Path> ds = Files.newDirectoryStream(dir);
        try {
            final Iterator<Path> delegate = ds.iterator();  //DirectoryStream迭代器

            // Re-wrap DirectoryIteratorException to UncheckedIOException
            Iterator<Path> it = new Iterator<Path>() { //创建新的迭代器
                @Override
                public boolean hasNext() {
                    try {
                        return delegate.hasNext(); //委托给DirectoryStream迭代器中的方法
                    } catch (DirectoryIteratorException e) {
                        throw new UncheckedIOException(e.getCause());
                    }
                }
                @Override
                public Path next() {
                    try {
                        return delegate.next();
                    } catch (DirectoryIteratorException e) {
                        throw new UncheckedIOException(e.getCause());
                    }
                }
            };

            return StreamSupport.stream(Spliterators.spliteratorUnknownSize(it, Spliterator.DISTINCT), false)
                                .onClose(asUncheckedRunnable(ds)); //创建分割迭代器
        } catch (Error|RuntimeException e) {
            try {
                ds.close();
            } catch (IOException ex) {
                try {
                    e.addSuppressed(ex);
                } catch (Throwable ignore) {}
            }
            throw e;
        }
    }

    /**
     * Return a {@code Stream} that is lazily populated with {@code
     * Path} by walking the file tree rooted at a given starting file.  The
     * file tree is traversed <em>depth-first</em>, the elements in the stream
     * are {@link Path} objects that are obtained as if by {@link
     * Path#resolve(Path) resolving} the relative path against {@code start}.
     *
     * <p> The {@code stream} walks the file tree as elements are consumed.  当元素被使用时，流遍历文件树
     * The {@code Stream} returned is guaranteed to have at least one 返回的stream保证至少有一个元素，开始文件自己
     * element, the starting file itself. For each file visited, the stream 对于访问的每个文件，the stream 尝试读取它自己的
     * attempts to read its {@link BasicFileAttributes}. If the file is a BasicFileAttributes ，如果文件是一个目录并且能够成功打开，进入当前目录，当遇到它们时，按照流中的目录进行操作
     * directory and can be opened successfully, entries in the directory, and 
     * their <em>descendants</em> will follow the directory in the stream as
     * they are encountered. When all entries have been visited, then the 当说有的实体已经访问，目录关闭
     * directory is closed. The file tree walk then continues at the next  然后继续文件树遍历下一个兄弟目录
     * <em>sibling</em> of the directory.
     *
     * <p> The stream is <i>weakly consistent</i>. It does not freeze the Stream是弱一直的。它不冻结Stream文件树当遍历时。
     * file tree while iterating, so it may (or may not) reflect updates to 因此它可能反映更新文件树
     * the file tree that occur after returned from this method. 发生在返回当前方法，也就是说在获取文件树后与当前的文件树可能不一致
     *
     * <p> By default, symbolic links are not automatically followed by this 通过这个方法，默认符号链接不是自动跟随的
     * method. If the {@code options} parameter contains the {@link ，如果options参数包含FileVisitOption#FOLLOW_LINKS
     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are 时，符号链接将跟随
     * followed. When following links, and the attributes of the target cannot 当跟随链接时，并且目标属性不能读时，这个方法尝试获取BasicFileAttributes的连接
     * be read, then this method attempts to get the {@code BasicFileAttributes}
     * of the link. 
     *
     * <p> If the {@code options} parameter contains the {@link 如果options参数包含FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS操作时
     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps stream跟踪访问的目录
     * track of directories visited so that cycles can be detected. A cycle  所以，可以检测到循环 ，当一个目录中的实体是一个祖先目录时，将出现一个循环
     * arises when there is an entry in a directory that is an ancestor of the
     * directory. Cycle detection is done by recording the {@link 循环检查 通过记录BasicFileAttributes#fileKey 对directories
     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories, 或者一个fike keys不可达时，通过调用isSameFile方法测试目录是否与祖先文件相同
     * or if file keys are not available, by invoking the {@link #isSameFile
     * isSameFile} method to test if a directory is the same file as an
     * ancestor. When a cycle is detected it is treated as an I/O error with 当检测到一个循环时，就对其进行处理,作为一个FileSystemLoopException异常
     * an instance of {@link FileSystemLoopException}.
     *
     * <p> The {@code maxDepth} parameter is the maximum number of levels of maxDepth参数是访问文件路最大等级
     * directories to visit. A value of {@code 0} means that only the starting 0意味着只访问starting目录
     * file is visited, unless denied by the security manager. A value of 除非被安全管理拒绝
     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all Integer#MAX_VALUE用于建设所有的等级
     * levels should be visited.
     *
     * <p> When a security manager is installed and it denies access to a file 当安全管理被安装，并且没访问权限，在stream中不包含
     * (or directory), then it is ignored and not included in the stream.
     *
     * <p> The returned stream encapsulates one or more {@link DirectoryStream}s.
     * If timely disposal of file system resources is required, the
     * {@code try}-with-resources construct should be used to ensure that the
     * stream's {@link Stream#close close} method is invoked after the stream
     * operations are completed.  Operating on a closed stream will result in an
     * {@link java.lang.IllegalStateException}.
     *
     * <p> If an {@link IOException} is thrown when accessing the directory
     * after this method has returned, it is wrapped in an {@link
     * UncheckedIOException} which will be thrown from the method that caused
     * the access to take place.
     *
     * @param   start
     *          the starting file
     * @param   maxDepth
     *          the maximum number of directory levels to visit
     * @param   options
     *          options to configure the traversal
     *
     * @return  the {@link Stream} of {@link Path}
     *
     * @throws  IllegalArgumentException
     *          if the {@code maxDepth} parameter is negative
     * @throws  SecurityException
     *          If the security manager denies access to the starting file.
     *          In the case of the default provider, the {@link
     *          SecurityManager#checkRead(String) checkRead} method is invoked
     *          to check read access to the directory.
     * @throws  IOException
     *          if an I/O error is thrown when accessing the starting file.
     * @since   1.8
     */
    public static Stream<Path> walk(Path start,
                                    int maxDepth,
                                    FileVisitOption... options)
        throws IOException
    {
        FileTreeIterator iterator = new FileTreeIterator(start, maxDepth, options); //文件树迭代器
        try {
            return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT), false) //创建文件树分割迭代器
                                .onClose(iterator::close) //完成后关闭
                                .map(entry -> entry.file()); //映射文件
        } catch (Error|RuntimeException e) {
            iterator.close();
            throw e;
        }
    }

    /**
     * Return a {@code Stream} that is lazily populated with {@code 返回一个Stream延迟填入Path
     * Path} by walking the file tree rooted at a given starting file.  The 遍历文件树根在给定的开始file
     * file tree is traversed <em>depth-first</em>, the elements in the stream 深度优先遍历文件树,流中元素的path对象
     * are {@link Path} objects that are obtained as if by {@link 通过Path#resolve(Path)解析相对路径获取
     * Path#resolve(Path) resolving} the relative path against {@code start}.
     *
     * <p> This method works as if invoking it were equivalent to evaluating the
     * expression:
     * <blockquote><pre>
     * walk(start, Integer.MAX_VALUE, options)
     * </pre></blockquote>
     * In other words, it visits all levels of the file tree. 它访问文件树的所有级别
     *
     * <p> The returned stream encapsulates one or more {@link DirectoryStream}s. 返回的stream压缩一个或多个DirectoryStream
     * If timely disposal of file system resources is required, the 如果文件系统资源需要立即处理时，try-with-resources 
     * {@code try}-with-resources construct should be used to ensure that the 结构应该被使用，确保Stream#close 方法调用，
     * stream's {@link Stream#close close} method is invoked after the stream 在stream操作完成后
     * operations are completed.  Operating on a closed stream will result in an  在封闭的流上运行将抛出IllegalStateException 
     * {@link java.lang.IllegalStateException}.
     *
     * @param   start
     *          the starting file
     * @param   options
     *          options to configure the traversal 配置遍历的选项
     *
     * @return  the {@link Stream} of {@link Path}
     *
     * @throws  SecurityException
     *          If the security manager denies access to the starting file.
     *          In the case of the default provider, the {@link
     *          SecurityManager#checkRead(String) checkRead} method is invoked
     *          to check read access to the directory.
     * @throws  IOException
     *          if an I/O error is thrown when accessing the starting file.
     *
     * @see     #walk(Path, int, FileVisitOption...)
     * @since   1.8
     */
    public static Stream<Path> walk(Path start, FileVisitOption... options) throws IOException {
        return walk(start, Integer.MAX_VALUE, options);
    }

    /**
     * Return a {@code Stream} that is lazily populated with {@code 返回一个Stream 延迟的Path
     * Path} by searching for files in a file tree rooted at a given starting 通过搜索根目录树的文件从给定的starting file开始
     * file.
     *
     * <p> This method walks the file tree in exactly the manner specified by 这个方法遍历文件树完全通过walk方法
     * the {@link #walk walk} method. For each file encountered, the given 每遇到一个文件，给定的BiPredicate将会执行Path
     * {@link BiPredicate} is invoked with its {@link Path} and {@link
     * BasicFileAttributes}. The {@code Path} object is obtained as if by 获取Path对象通过Path#resolve(Path)解析相对于start的相对路径
     * {@link Path#resolve(Path) resolving} the relative path against {@code
     * start} and is only included in the returned {@link Stream} if 只包含BiPredicate返回true的Stream
     * the {@code BiPredicate} returns true. Compare to calling {@link 在Stream调用filter进行比较
     * java.util.stream.Stream#filter filter} on the {@code Stream}
     * returned by {@code walk} method, this method may be more efficient by 这种方法可能更有效，避免多余的检索
     * avoiding redundant retrieval of the {@code BasicFileAttributes}.
     *
     * <p> The returned stream encapsulates one or more {@link DirectoryStream}s. 返回的Stream压缩一个或多个DirectoryStream
     * If timely disposal(如果需要及时处理文件系统资源) of file system resources is required, the 
     * {@code try}-with-resources construct should be used to ensure that the try-with-resources结构将被使用，以确保流的关闭，在Stream#close 方法调用后流的操作完成
     * stream's {@link Stream#close close} method is invoked after the stream
     * operations are completed.  Operating on a closed stream(在封闭的流上运行) will result in an 
     * {@link java.lang.IllegalStateException}.
     *
     * <p> If an {@link IOException} is thrown when accessing the directory
     * after returned from this method, it is wrapped in an {@link
     * UncheckedIOException} which will be thrown from the method that caused
     * the access to take place.
     *
     * @param   start
     *          the starting file 开始file
     * @param   maxDepth
     *          the maximum number of directory levels to search 要搜索的目录级别
     * @param   matcher
     *          the function used to decide whether a file should be included
     *          in the returned stream
     * @param   options
     *          options to configure the traversal 配置遍历的选项
     *
     * @return  the {@link Stream} of {@link Path}
     *
     * @throws  IllegalArgumentException
     *          if the {@code maxDepth} parameter is negative
     * @throws  SecurityException
     *          If the security manager denies access to the starting file.
     *          In the case of the default provider, the {@link
     *          SecurityManager#checkRead(String) checkRead} method is invoked
     *          to check read access to the directory.
     * @throws  IOException
     *          if an I/O error is thrown when accessing the starting file.
     *
     * @see     #walk(Path, int, FileVisitOption...)
     * @since   1.8
     */
    public static Stream<Path> find(Path start,
                                    int maxDepth,
                                    BiPredicate<Path, BasicFileAttributes> matcher,
                                    FileVisitOption... options)
        throws IOException
    {
        FileTreeIterator iterator = new FileTreeIterator(start, maxDepth, options); //一个遍历文件树的节点迭代器
        try {
            return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT), false) //创建分割迭代器
                                .onClose(iterator::close) //关闭
                                .filter(entry -> matcher.test(entry.file(), entry.attributes())) //过滤
                                .map(entry -> entry.file()); //映射
        } catch (Error|RuntimeException e) {
            iterator.close();
            throw e;
        }
    }

    /**
     * Read all lines from a file as a {@code Stream}. Unlike {@link 读取所有行作为Stream
     * #readAllLines(Path, Charset) readAllLines}, this method does not read 不像readAllLines，这个方法不是读取所有行到List
     * all lines into a {@code List}, but instead populates lazily as the stream 作为流消费延迟代替
     * is consumed.
     *
     * <p> Bytes from the file are decoded into characters using the specified 使用指定的charset
     * charset and the same line terminators as specified by {@code
     * readAllLines} are supported.
     *
     * <p> After this method returns, then any subsequent I/O exception that 方法返回后，任意后续发生的从文件读取的IO异常
     * occurs while reading from the file or when a malformed or unmappable byte 
     * sequence is read, is wrapped in an {@link UncheckedIOException} that will 包装为UncheckedIOException异常抛出
     * be thrown from the
     * {@link java.util.stream.Stream} method that caused the read to take
     * place. In case an {@code IOException} is thrown when closing the file,当关闭file时，如果抛出IOException，它也包装为UncheckedIOException
     * it is also wrapped as an {@code UncheckedIOException}.
     *
     * <p> The returned stream encapsulates a {@link Reader}.  If timely 返回的流压缩一个Reader，如果及时处理需要的文件系统资源，try-with-resources 结果应该被使用，确保stream的close方法被调用在流完成时
     * disposal of file system resources is required, the try-with-resources 
     * construct should be used to ensure that the stream's
     * {@link Stream#close close} method is invoked after the stream operations
     * are completed.
     *
     *
     * @param   path
     *          the path to the file
     * @param   cs
     *          the charset to use for decoding 解码charset
     *
     * @return  the lines from the file as a {@code Stream}
     *
     * @throws  IOException
     *          if an I/O error occurs opening the file
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, the {@link SecurityManager#checkRead(String) checkRead}
     *          method is invoked to check read access to the file.
     *
     * @see     #readAllLines(Path, Charset)
     * @see     #newBufferedReader(Path, Charset)
     * @see     java.io.BufferedReader#lines()
     * @since   1.8
     */
    public static Stream<String> lines(Path path, Charset cs) throws IOException {
        BufferedReader br = Files.newBufferedReader(path, cs);
        try {
            return br.lines().onClose(asUncheckedRunnable(br)); //关闭
        } catch (Error|RuntimeException e) {
            try {
                br.close();
            } catch (IOException ex) {
                try {
                    e.addSuppressed(ex);
                } catch (Throwable ignore) {}
            }
            throw e;
        }
    }

    /**
     * Read all lines from a file as a {@code Stream}. Bytes from the file are 从文件中读取所有行作为Stream，从文件获取的字节是使用UTF-8解码的
     * decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}
     * {@link Charset charset}.
     *
     * <p> This method works as if invoking it were equivalent等于 to evaluating the
     * expression:
     * <pre>{@code
     * Files.lines(path, StandardCharsets.UTF_8)
     * }</pre>
     *
     * @param   path
     *          the path to the file
     *
     * @return  the lines from the file as a {@code Stream}
     *
     * @throws  IOException
     *          if an I/O error occurs opening the file
     * @throws  SecurityException
     *          In the case of the default provider, and a security manager is
     *          installed, the {@link SecurityManager#checkRead(String) checkRead}
     *          method is invoked to check read access to the file.
     *
     * @since 1.8
     */
    public static Stream<String> lines(Path path) throws IOException {
        return lines(path, StandardCharsets.UTF_8);
    }

```




