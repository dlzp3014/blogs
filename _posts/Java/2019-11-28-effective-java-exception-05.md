---
layout: post
title: "Java中应使失败保持原子性"
date: 2019-11-28 08:38:00
categories: Java 
tags: Effective-Java
---

* content
{:toc}


当对象抛出异常之后，通常希望这个对象仍然保持在一种定义良好的可用状态之中(即使在执行某个操作过程中间发生的失败)。对于受检查异常而言，保持对象的可用状态尤为重要: 调用者期望能从这种异常中进行修复。一般而言，`调用失败的方法应该使对象保持在被调用之前的状态，而具有这种属性的方法则被称为具有失败原子性(failure atomic)`。要实现这种效果，参考的设计方法如下:






- 设计一个不可变对象

如果对象是不可变的，失败原子性就是显然的。如果一个操作失败，可能会阻止创建新的对象，但是永远不会使已有的不可变对象保持在不一致的状态之中，因为当每个对象被创建之后它就处于一致的状态之中，以后也不会再发生变化


- 执行操作之前，检查参数的有效性

对于在可变对象删执行操作的方法，获得失败原子性最常见的方法就是在执行操作之前，检查参数的有效性，这可以使得在对象的状态被修改之前，先抛出适当的异常。

- 调整程序计算处理的过程顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生


- 在对象的一份拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容

如有些排序函数在执行排序之前，先会把输入列表备份到一个数组中，以便降低在排序的内循环中访问元素所需要的开销(处于性能考虑的做法)，其也增加了一项优势: 即使排序失败，也能保证输入列表保存原来的顺序


- 编写可恢复代码(recoery code)来拦截操作过程中发生的失败，使对象回滚到操作开始之前的状态(不常用)

这种方法主要用于永久的(基于磁盘的)数据结果

虽然一般情况下都希望实现失败原子性，但是并非总是可以做到的。如两个线程视图在没有适当的同步机制的情况下，并发地修改同一个对象，这个对象就可能被留在不一致的状态之中。因此，在捕获了`ConcurrentModificationException`异常之后再假设对象仍然是可用的是错误的(错误通常是不可恢复的)。所以当方法抛出此类异常时，不需要去保存失败原子性


即使在可以实现失败原子性的场合，其也并不是所期望的: `对于某些操作它会显著地增加开销或者复杂性，即失败原子性往往既简单又容易`


总结: `作为方法规范的一部分，其产生的任何异常都应该让对象保持在调用该方法之前的状态`。如果违反了这条规则，API文档就应该清楚地指明对象将会处于怎样的状态




