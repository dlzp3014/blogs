---
layout: post
title:  "用Optional取代Null"
date:   2018-07-09 22:42:23
categories: Java 
tags: jdk1.8 Optional
---

* content
{:toc}

Null设计初衷为“通过编译器的自动检测机制，确保所有使用引用的地方都是绝对安全的”，将null引用建模为“不存在的值”，其带来的后果是对对象的检测，判断它的值为期望的格式，最终却发现查看的不是一个对象，而是一个空指针，立即抛出一个NullPointerException异常




## Null值建模

如下:获取用户的名字
```java
public static String getUserName(User user){
	//如果User对象为Null，将抛出NullPointerException，终止程序的运行 
	return user.getUserName();
}
```

### 防御检测
在需要的地方添加null的检测(过于激进的检测甚至会在不太需要的地方添加检测代码)

```java
public static String getUserName(User user){
	//添加null检测，如果嵌套对过多时，将导致每次引用一个变量都会做一次null检测，增加新的退出点，代码的维护异常艰难
	if(null==user){
		return null;
	} 
	return user.getUserName();
}
```

### null所带来的问题
- NullPointerException  
Java程序中最典型的异常
- 代码膨胀  
充斥着深度的null检查，代码可读性降低
- null自身没有任何语义  
仅代表在静态类型语言中以一种错误的方式对缺失变量值的建模
- 违背Java哲学  
Java避免让程序员意识到指针的存在，唯独null指针例外
- null不属于任何类型  
意味着可以被赋值给任意引用类型的变量，带着股变量被传递到系统中的另一部分后，无法获知这个null变量最初的赋值到底是什么类型

## java.util.Optional<T>类
一个封装Optional值的类，如将User`可能为null`直接声明为Optional<User>类型。User存在时，Optional只是对User简单的封装;User为null时，缺失的值会被建模成一个“空”的Optional对象，由方法Optional.empty()返回。Optional.empty()是一个静态工厂方法，返回Optional类的特定单一实例。  
null和Optional.empty()本质区别：
- 语义上可以把它们当做一回事
- 引用一个null，一定会触发NullPointerException，使用Optional.empty()没事，它是Optional类的一个有效对象，多种场景都能调用
`使用Optional而不是null的一个重要而实际的语义区别是：在声明变量时用的Optional<T>，可以清楚的表明这里发生变量缺失是允许的`，如下使用Optional重新定义getUserName():
```java
public static String getUserName(Optional<Person> person) {
	//如果Optional的结果为空，返回空字符串
	return person.flatMap(Person::getUserName).orElse("");
}
```

`注：在代码中始终如一的使用Optional，能非常清楚的界定出变量值的缺失是结构上的问题，还是算法上的缺陷，或是数据中的问题`，引用Optional类的意图并非要消除每一个null引用。与此相反，它的目标是帮助更好的设计出普适的API，看到方法签名就能了解到它是否接受一个Optional的值。

## 应用Optional模式
使用Optional类型来声明域模型

### 创建Optional对象
- 声明一个空的Optional
通过静态工厂方法Optional.empty()，创建一个空的Optional对象
```java
Optional<User> optUser=Optional.empty();
```

- 依据一个非空值创建Optional
可以使用静态工厂方法Optional.of，依据一个非空值创建一个Optional对象
```java
Optional<User> optUser=Optional.of(user);
```
`如果user为null时，立即抛出NullPointerException，而不是等到试图访问User的属性值时才返回一个错误`

- 可接收null的Optional
使用静态工厂方法Optional.ofNullable，可以创建一个允许null值的Optional对象
```java
Optional<User> optUser=Optional.ofNullable(user);
```
`注：user null时，得到的Optional对象就是一个空对象`

获取Optional变量中的值：Optional提供了一个get方法，不过get方法在遇到空的Optional对象时也会抛出异常，所以不按约定的方式使用它，又会再度陷入由null引起的代码维护难的问题

### 使用map从Optional对象中提取和转换值
`无需显示检查的Optional值`:Optional提供一个map方法，map操作会将提供的函数应用于流的每个元素。如果Optional包含一个值，那函数就将该值作为参数传递给map，对该值进行转换。如果Optional为空，什么也不做，如果工作方式如下：
```java
Optional<User> optUser = Optional.ofNullable(user);
Optional<String> name= optUser.map(User::getName);
```

### 使用flagMap连接Optional对象
flagMap方法接收一个函数作为参数，这个函数的返回值是另一个流，该方法会应用到流中的每一个元素，最终形成一个新的流的流，但flagMap会用流的内容替换每个新生成的流，可以理解为`由方法生成的各个流被合并或者扁平化为一个单一的流`






