---
layout: post
title:  "Stream 介绍"
date:   2019-01-24 22:17:23
categories: Java 
tags: jdk1.8 Stream
---

* content
{:toc}

Stream是Jdk1.8引进的成员，允许以声明性方式处理数据集合（通过查询语句来表达而非临时编写一个实现），可以把流看成遍历数据集的高级迭代器。流可以透明地并行处理，无需写任何多线程代码。




## 流简介

Java8中的集合支持一个新的stream方法，它返回一个流(接口定义在java.util.stream.Stream里)，那么流到底是什么，简短的定义就是`从支持数据处理操作的源生成的元素序列`

- 元素序列 可以访问特定元素类型的一组有序值
集合是`数据结构`，主要目的是以特定的时间、空间复杂度存储和访问元素，如ArrayList/LinkedList；流的目的在于`表述计算`，集合讲的是数据，流讲的是计算

- 源 流会使用一个提供数据的源，如集合、数组、输入或输出资源.从有序集合生成流时会保留原有的顺序，由列表生成的流其元素顺序与列表一致

- 数据处理操作 流的数据处理能力支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter map reduce find match sort等，流操作可以顺序执行也可以并行执行

- 流水线 很多流操作本身会返回一个流，这样多个操作可以链接起来，形成一个大的流水线。流水线的操作可以看作对`数据源进行数据库式查询`

- 内部迭代 与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的，

如下代码中的体现：
```java
list          //数据源
	.stream() //建立操作流水线
	.filter() //过滤元素,接收Lambda，从流中排除某些元素 
	.map() //映射，接收Lambda，将元素转换成其他形式或提取信息
	.limit() // 限制，截断流，使其元素不超过给定数量
	collect(toList) //聚合，将流转换为其他形式，在调用collect方法之前，没有任何结果产生。链中的方法调用都在排队等待，直到调用collect
```


## 流与集合

java现有的集合和流都提供了接口，来配合代表元素类型有序值的数据接口。所谓有序，就是按顺序取值，而不是随机取值.【从哲学的角度看：可以把流看作在时间中分布的一组值，集合则是空间(计算机内存)中分布的一组值】

- 集合与流之间的差异：
集合是一个内存中的数据结构，它包含数据结构目前所有的值，集合中的每个元素都得先算出来才能添加到集合中(可以往集合里添加或删除元素，但不管什么时候集合中的每个元素都是放在内存里的，元素都得先算出来才能成为集合的一部分)
---
流是固定的数据结构，不能添加或删除元素，其元素是按需计算的(这种思想就是用户仅仅从流中提取需要的值，而这些值对用户来说是透明的，只需按需生产)，这是一种生产消费的关系；从另一个角度看，流就像是一个延迟的集合，只有在消费者要求的时候才会计算之。于此相反集合则是急切创建的

## 流只能遍历一次
【Note】:流只能消费一次
流只能遍历一次，遍历完成后，当前流就已经被消费掉(可以从原始数据那在获得一个新的流来重新遍历一遍，如集合之类的可重复的源，如果是IO通道就不行)

## 外部迭代与内部迭代
外部迭代：使用Collection接口需要用户去做迭代，如for-each，显式地取出每元素在加以处理
内部迭代：Streams库使用内部迭代，它帮你把迭代做了，如map(b->b.length)，由stream内部处理需要将元素转换为你想要的类型

## 流操作分类
中间操作：可以连接起来的流；终端操作：关闭流的操作

### 中间操作

中间操作会返回另一个流，这让多个操作可以连接起来形成一个查询。`除非流水线上触发一个终端操作，否则中间操作不会执行任何处理，即惰性操作，流的延迟性，这是因为中间操作一般都可以合并起来，在终端操作时一次性全部处理`

如下流处理操作:
	list.stream().filter().map().limit().collect(toList())
有好几种优化利用了流的延迟性质：尽管符合条件的列表很多，只能选出前三个，只是因为limit操作为一种短路；filter map是两个独立操作，但它们合并到同一次遍历中(循环合并)

### 终端操作
终端操作会从流水线上生成结果，其结果不是任何流的值

### 流的使用过程
流使用一般包括三件事：
- 一个数据源来执行一个查询
- 一个中间操作链，形成一条流的流水线
- 一个终端操作，执行流水线，并生成结果

流的流水线背后的理念类似于构建者模式，在构建者模式中有一个调用链来设置一套配置(对流来说这就是一个中间操作链)，接着是调用build方法(对流来说就是终端操作)

## 分别使用Java7、Java8过滤、排序、映射元素
```java

final List<Integer> items = Arrays.asList(1, 2, 4, 5, 6, 8, 10, 12);

/**
 * JDK1.7之前对结合的操作
 */
public void operator17() {
    List<Integer> resultInt = new ArrayList<>();
    for (Integer item : items) {
        if (item < 10) {
            resultInt.add(item);
        }
    }
    Collections.sort(resultInt, new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return Integer.compare(o1, 02);
        }
    });
    List<String> resultStr = new ArrayList<>();
    for (Integer item : resultInt) {
        resultStr.add(item.toString());
    }
    System.out.println(resultStr);
}

/**
 * JDK1.8之后对集合的操作
 */
public void operator18() {

    List<String> resultStr = items.stream().filter(i -> i < 10)
            .sorted(Integer::compare)
            .map(String::valueOf)
            .collect(toList());
    System.out.println(resultStr);

}

```
## 总结
在Java8中，实现的细节被放在它本该归属的库里，新的使用方式有如下好处：
- 代码是以`声明性方式`编写的：说明想要完成什么，而不是说明如何实现一个操作，这种方式加上行为参数化可以轻松应对变化的需求
- 可以把几个基础操作链接起来，来表达复杂的数据处理流水线，同时保持代码清晰可读，如filter的结果被传给了sorted、再传给mao，最后聚合collect。因为filter、sorted、map、collect等操作是与具体线程模型无关的高层次构建，所以它们的内部实现可以是单线程的，也可以多线程执行，这意味着不用为了某些数据处理任务并行而去操心线程和锁。
：Java8中的Stream API 可以写出如下代码：
- 声明性 更简洁，更易读
- 可复合 更灵活
- 可并行 性能更好




